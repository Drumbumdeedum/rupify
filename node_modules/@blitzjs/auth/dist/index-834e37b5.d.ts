import * as blitz from 'blitz';
import { Ctx, BlitzServerPlugin, RouteUrlObject } from 'blitz';
import * as bad_behavior from 'bad-behavior';
import { UrlObject } from 'url';
import React, { ComponentType, ComponentPropsWithoutRef } from 'react';

declare const TOKEN_SEPARATOR = ";";
declare const HANDLE_SEPARATOR = ":";
declare const SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = "ots";
declare const SESSION_TYPE_ANONYMOUS_JWT = "ajwt";
declare const SESSION_TOKEN_VERSION_0 = "v0";
declare const COOKIE_ANONYMOUS_SESSION_TOKEN: () => string;
declare const COOKIE_SESSION_TOKEN: () => string;
declare const COOKIE_REFRESH_TOKEN: () => string;
declare const COOKIE_CSRF_TOKEN: () => string;
declare const COOKIE_PUBLIC_DATA_TOKEN: () => string;
declare const HEADER_CSRF = "anti-csrf";
declare const HEADER_PUBLIC_DATA_TOKEN = "public-data-token";
declare const HEADER_SESSION_CREATED = "session-created";
declare const HEADER_CSRF_ERROR = "csrf-error";
declare const LOCALSTORAGE_PREFIX = "_blitz-";
declare const LOCALSTORAGE_CSRF_TOKEN: () => string;
declare const LOCALSTORAGE_PUBLIC_DATA_TOKEN: () => string;

interface Session {
}
declare type PublicData = Session extends {
    PublicData: unknown;
} ? Session["PublicData"] : {
    userId: unknown;
    role?: unknown;
};
interface EmptyPublicData extends Partial<Omit<PublicData, "userId">> {
    userId: PublicData["userId"] | null;
    role?: PublicData["role"] | null;
}
interface ClientSession extends EmptyPublicData {
    isLoading: boolean;
}
interface AuthenticatedClientSession extends PublicData {
    isLoading: boolean;
}
declare type IsAuthorizedArgs = Session extends {
    isAuthorized: (...args: any) => any;
} ? "args" extends keyof Parameters<Session["isAuthorized"]>[0] ? Parameters<Session["isAuthorized"]>[0]["args"] : unknown[] : unknown[];
interface SessionModel extends Record<any, any> {
    handle: string;
    userId?: PublicData["userId"] | null;
    expiresAt?: Date | null;
    hashedSessionToken?: string | null;
    antiCSRFToken?: string | null;
    publicData?: string | null;
    privateData?: string | null;
}
interface SessionConfigMethods {
    getSession: (handle: string) => Promise<SessionModel | null>;
    getSessions: (userId: PublicData["userId"]) => Promise<SessionModel[]>;
    createSession: (session: SessionModel) => Promise<SessionModel>;
    updateSession: (handle: string, session: Partial<SessionModel>) => Promise<SessionModel | undefined>;
    deleteSession: (handle: string) => Promise<SessionModel | undefined>;
}
interface SessionContextBase {
    $handle: string | null;
    $publicData: unknown;
    $authorize(...args: IsAuthorizedArgs): asserts this is AuthenticatedSessionContext;
    $isAuthorized: (...args: IsAuthorizedArgs) => boolean;
    $thisIsAuthorized: (...args: IsAuthorizedArgs) => this is AuthenticatedSessionContext;
    $create: (publicData: PublicData, privateData?: Record<any, any>) => Promise<void>;
    $revoke: () => Promise<void>;
    $revokeAll: () => Promise<void>;
    $getPrivateData: () => Promise<Record<any, any>>;
    $setPrivateData: (data: Record<any, any>) => Promise<void>;
    $setPublicData: (data: Partial<Omit<PublicData, "userId">>) => Promise<void>;
}
interface SessionContext extends SessionContextBase, EmptyPublicData {
    $publicData: Partial<PublicData> | EmptyPublicData;
}
interface AuthenticatedSessionContext extends SessionContextBase, PublicData {
    userId: PublicData["userId"];
    $publicData: PublicData;
}
declare module "blitz" {
    interface Ctx {
        session: SessionContext;
    }
}
declare type BlitzCtx = Ctx;

interface SessionConfigOptions {
    cookiePrefix?: string;
    sessionExpiryMinutes?: number;
    anonSessionExpiryMinutes?: number;
    method?: "essential" | "advanced";
    sameSite?: "none" | "lax" | "strict";
    secureCookies?: boolean;
    domain?: string;
    publicDataKeysToSyncAcrossSessions?: string[];
}
interface IsAuthorized {
    isAuthorized: (data: {
        ctx: Ctx;
        args: any;
    }) => boolean;
}
interface PrismaClientWithSession {
    session: {
        findFirst(args?: {
            where?: {
                handle?: SessionModel["handle"];
            };
        }): Promise<SessionModel | null>;
        findMany(args?: {
            where?: {
                userId?: PublicData["userId"];
            };
        }): Promise<SessionModel[]>;
        create(args: {
            data: SessionModel & {
                userId?: any;
                user?: {
                    connect: {
                        id: any;
                    };
                };
            };
        }): Promise<SessionModel>;
        update(args: {
            data: Partial<SessionModel>;
            where: {
                handle?: SessionModel["handle"];
            };
        }): Promise<SessionModel>;
        delete(args: {
            where: {
                handle?: SessionModel["handle"];
            };
        }): Promise<SessionModel>;
    };
}
declare const PrismaStorage: <Client extends PrismaClientWithSession>(db: Client) => SessionConfigMethods;
interface AuthPluginOptions extends Partial<SessionConfigOptions>, IsAuthorized {
    storage: SessionConfigMethods;
}
declare function AuthServerPlugin(options: AuthPluginOptions): BlitzServerPlugin<any, any>;

declare global {
    var sessionConfig: AuthPluginOptions & SessionConfigMethods;
    var __BLITZ_SESSION_COOKIE_PREFIX: string | undefined;
    var __BLITZ_SUSPENSE_ENABLED: boolean;
}

declare const parsePublicDataToken: (token: string) => {
    publicData: {
        userId: unknown;
        role?: unknown;
    };
};
declare class PublicDataStore {
    private eventKey;
    readonly observable: {
        next: (n: {
            userId: unknown;
            role?: unknown;
        } | EmptyPublicData) => void;
        subscribe: (fn: bad_behavior.ISubscriber<{
            userId: unknown;
            role?: unknown;
        } | EmptyPublicData>) => {
            unsubscribe(): void;
        };
    };
    constructor();
    updateState(value?: PublicData | EmptyPublicData, opts?: {
        suppressEvent: boolean;
    }): void;
    clear(): void;
    getData(): {
        userId: unknown;
        role?: unknown;
    };
    private getToken;
}
declare const getPublicDataStore: () => PublicDataStore;
declare const backupAntiCSRFTokenToLocalStorage: () => void;
declare const getAntiCSRFToken: () => any;
interface UseSessionOptions {
    initialPublicData?: PublicData;
    suspense?: boolean | null;
}
declare const useSession: (options?: UseSessionOptions) => ClientSession;
declare const useAuthorizeIf: (condition?: boolean, role?: string | Array<string>) => void;
declare const useAuthorize: () => void;
declare const useAuthenticatedSession: (options?: UseSessionOptions) => AuthenticatedClientSession;
declare const useRedirectAuthenticated: (to: UrlObject | string) => void;
declare type RedirectAuthenticatedTo = string | RouteUrlObject | false;
declare type RedirectAuthenticatedToFnCtx = {
    session: Ctx["session"]["$publicData"];
};
declare type RedirectAuthenticatedToFn = (args: RedirectAuthenticatedToFnCtx) => RedirectAuthenticatedTo;
declare type BlitzPage<P = {}> = React.ComponentType<P> & {
    getLayout?: (component: JSX.Element) => JSX.Element;
    authenticate?: boolean | {
        redirectTo?: string | RouteUrlObject;
        role?: string | Array<string>;
    };
    suppressFirstRenderFlicker?: boolean;
    redirectAuthenticatedTo?: RedirectAuthenticatedTo | RedirectAuthenticatedToFn;
};
declare function getAuthValues<TProps = any>(Page: ComponentType<TProps> | BlitzPage, props: ComponentPropsWithoutRef<BlitzPage>): {
    authenticate?: undefined;
    redirectAuthenticatedTo?: undefined;
} | {
    authenticate: boolean | {
        redirectTo?: string | RouteUrlObject | undefined;
        role?: string | string[] | undefined;
    } | undefined;
    redirectAuthenticatedTo: RedirectAuthenticatedTo | RedirectAuthenticatedToFn | undefined;
};
interface AuthPluginClientOptions {
    cookiePrefix: string;
}
declare const AuthClientPlugin: (options: AuthPluginClientOptions) => blitz.ClientPlugin<{
    useSession: (options?: UseSessionOptions) => ClientSession;
    useAuthorize: () => void;
    useAuthorizeIf: (condition?: boolean, role?: string | Array<string>) => void;
    useRedirectAuthenticated: (to: UrlObject | string) => void;
    useAuthenticatedSession: (options?: UseSessionOptions) => AuthenticatedClientSession;
    getAntiCSRFToken: () => any;
}>;

export { AuthPluginClientOptions as A, BlitzPage as B, COOKIE_ANONYMOUS_SESSION_TOKEN as C, ClientSession as D, EmptyPublicData as E, AuthenticatedClientSession as F, SessionModel as G, HANDLE_SEPARATOR as H, IsAuthorizedArgs as I, SessionConfigMethods as J, SessionContextBase as K, LOCALSTORAGE_PREFIX as L, SessionContext as M, AuthenticatedSessionContext as N, BlitzCtx as O, PublicData as P, PrismaStorage as Q, RedirectAuthenticatedTo as R, SESSION_TYPE_OPAQUE_TOKEN_SIMPLE as S, TOKEN_SEPARATOR as T, UseSessionOptions as U, AuthPluginOptions as V, AuthServerPlugin as W, getAntiCSRFToken as a, backupAntiCSRFTokenToLocalStorage as b, useAuthorizeIf as c, useAuthorize as d, useAuthenticatedSession as e, useRedirectAuthenticated as f, getPublicDataStore as g, RedirectAuthenticatedToFnCtx as h, RedirectAuthenticatedToFn as i, getAuthValues as j, AuthClientPlugin as k, SESSION_TYPE_ANONYMOUS_JWT as l, SESSION_TOKEN_VERSION_0 as m, COOKIE_SESSION_TOKEN as n, COOKIE_REFRESH_TOKEN as o, parsePublicDataToken as p, COOKIE_CSRF_TOKEN as q, COOKIE_PUBLIC_DATA_TOKEN as r, HEADER_CSRF as s, HEADER_PUBLIC_DATA_TOKEN as t, useSession as u, HEADER_SESSION_CREATED as v, HEADER_CSRF_ERROR as w, LOCALSTORAGE_CSRF_TOKEN as x, LOCALSTORAGE_PUBLIC_DATA_TOKEN as y, Session as z };
