'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./chunks/index.cjs');
const b64Lite = require('b64-lite');
const cookie = require('cookie');
const jsonwebtoken = require('jsonwebtoken');
const blitz = require('blitz');
const crypto = require('crypto');
const nanoid = require('nanoid');
const SecurePasswordLib = require('secure-password');
const cookieSession = require('cookie-session');
const passport = require('passport');
require('bad-behavior');
require('react');
require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const cookie__default = /*#__PURE__*/_interopDefaultLegacy(cookie);
const crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);
const SecurePasswordLib__default = /*#__PURE__*/_interopDefaultLegacy(SecurePasswordLib);
const cookieSession__default = /*#__PURE__*/_interopDefaultLegacy(cookieSession);
const passport__default = /*#__PURE__*/_interopDefaultLegacy(passport);

var __defProp$3 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const hash256 = (input = "") => {
  return crypto__namespace.createHash("sha256").update(input).digest("hex");
};
const generateToken = (numberOfCharacters = 32) => nanoid.nanoid(numberOfCharacters);
const SP = () => new SecurePasswordLib__default();
const SecurePassword = __spreadProps$2(__spreadValues$3({}, SecurePasswordLib__default), {
  hash(password) {
    return __async$3(this, null, function* () {
      if (!password) {
        throw new blitz.AuthenticationError();
      }
      const hashedBuffer = yield SP().hash(Buffer.from(password));
      return hashedBuffer.toString("base64");
    });
  },
  verify(hashedPassword, password) {
    return __async$3(this, null, function* () {
      if (!hashedPassword || !password) {
        throw new blitz.AuthenticationError();
      }
      try {
        const result = yield SP().verify(Buffer.from(password), Buffer.from(hashedPassword, "base64"));
        switch (result) {
          case SecurePassword.VALID:
          case SecurePassword.VALID_NEEDS_REHASH:
            return result;
          default:
            throw new blitz.AuthenticationError();
        }
      } catch (error) {
        throw new blitz.AuthenticationError();
      }
    });
  }
});

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isLocalhost(req) {
  let { host } = req.headers;
  let localhost = false;
  if (host) {
    host = host.split(":")[0];
    localhost = host === "localhost";
  }
  return localhost;
}
function getCookieParser(headers) {
  return function parseCookie() {
    const header = headers.cookie;
    if (!header) {
      return {};
    }
    return cookie.parse(Array.isArray(header) ? header.join(";") : header);
  };
}
const debug = require("debug")("blitz:session");
const simpleRolesIsAuthorized = ({ ctx, args }) => {
  const [roleOrRoles] = args;
  const publicData = ctx.session.$publicData;
  if ("role" in publicData && "roles" in publicData) {
    throw new Error("Session publicData can only have only `role` or `roles`, but not both.'");
  }
  let roles = [];
  if ("role" in publicData) {
    if (typeof publicData.role !== "string") {
      throw new Error("Session publicData.role field must be a string");
    }
    roles.push(publicData.role);
  } else if ("roles" in publicData) {
    if (!Array.isArray(publicData.roles)) {
      throw new Error("Session `publicData.roles` is not an array, but it must be");
    }
    roles = publicData.roles;
  } else {
    throw new Error("Session publicData is missing the required `role` or roles` field");
  }
  if (!roleOrRoles)
    return true;
  const rolesToAuthorize = [];
  if (Array.isArray(roleOrRoles)) {
    rolesToAuthorize.push(...roleOrRoles);
  } else if (roleOrRoles) {
    rolesToAuthorize.push(roleOrRoles);
  }
  for (const role of rolesToAuthorize) {
    if (roles.includes(role))
      return true;
  }
  return false;
};
function ensureApiRequest(req) {
  if (!("cookies" in req)) {
    req.cookies = getCookieParser(req.headers)();
  }
}
function ensureMiddlewareResponse(res) {
  if (!("blitzCtx" in res)) {
    res.blitzCtx = {};
  }
}
function getSession(req, res) {
  return __async$2(this, null, function* () {
    ensureApiRequest(req);
    ensureMiddlewareResponse(res);
    debug("cookiePrefix", globalThis.__BLITZ_SESSION_COOKIE_PREFIX);
    if (res.blitzCtx.session) {
      return res.blitzCtx.session;
    }
    let sessionKernel = yield getSessionKernel(req, res);
    if (sessionKernel) {
      debug("Got existing session", sessionKernel);
    }
    if (!sessionKernel) {
      debug("No session found, creating anonymous session");
      sessionKernel = yield createAnonymousSession(req, res);
    }
    const sessionContext = makeProxyToPublicData(new SessionContextClass(req, res, sessionKernel));
    res.blitzCtx.session = sessionContext;
    return sessionContext;
  });
}
const makeProxyToPublicData = (ctxClass) => {
  return new Proxy(ctxClass, {
    get(target, prop, receiver) {
      if (prop in target || prop === "then") {
        return Reflect.get(target, prop, receiver);
      } else {
        return Reflect.get(target.$publicData, prop, receiver);
      }
    }
  });
};
class SessionContextClass {
  constructor(req, res, kernel) {
    this._req = req;
    this._res = res;
    this._kernel = kernel;
  }
  get $handle() {
    return this._kernel.handle;
  }
  get userId() {
    return this._kernel.publicData.userId;
  }
  get $publicData() {
    return this._kernel.publicData;
  }
  $authorize(...args) {
    const e = new blitz.AuthenticationError();
    Error.captureStackTrace(e, this.$authorize);
    if (!this.userId)
      throw e;
    if (!this.$isAuthorized(...args)) {
      const err = new blitz.AuthorizationError();
      Error.captureStackTrace(err, this.$authorize);
      throw err;
    }
  }
  $isAuthorized(...args) {
    if (!this.userId)
      return false;
    return global.sessionConfig.isAuthorized({ ctx: this._res.blitzCtx, args });
  }
  $thisIsAuthorized(...args) {
    return this.$isAuthorized(...args);
  }
  $create(publicData, privateData) {
    return __async$2(this, null, function* () {
      this._kernel = yield createNewSession({
        req: this._req,
        res: this._res,
        publicData,
        privateData,
        jwtPayload: this._kernel.jwtPayload,
        anonymous: false
      });
    });
  }
  $revoke() {
    return __async$2(this, null, function* () {
      this._kernel = yield revokeSession(this._req, this._res, this.$handle);
    });
  }
  $revokeAll() {
    return __async$2(this, null, function* () {
      yield this.$revoke();
      yield revokeAllSessionsForUser(this.$publicData.userId);
      return;
    });
  }
  $setPublicData(data) {
    return __async$2(this, null, function* () {
      if (this.userId) {
        yield syncPubicDataFieldsForUserIfNeeded(this.userId, data);
      }
      this._kernel.publicData = yield setPublicData(this._req, this._res, this._kernel, data);
    });
  }
  $getPrivateData() {
    return __async$2(this, null, function* () {
      return (yield getPrivateData(this.$handle)) || {};
    });
  }
  $setPrivateData(data) {
    return setPrivateData(this._kernel, data);
  }
}
const TOKEN_LENGTH = 32;
const generateEssentialSessionHandle = () => {
  return generateToken(TOKEN_LENGTH) + index.HANDLE_SEPARATOR + index.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
};
const generateAnonymousSessionHandle = () => {
  return generateToken(TOKEN_LENGTH) + index.HANDLE_SEPARATOR + index.SESSION_TYPE_ANONYMOUS_JWT;
};
const createSessionToken = (handle, publicData) => {
  let publicDataString;
  if (typeof publicData === "string") {
    publicDataString = publicData;
  } else {
    publicDataString = JSON.stringify(publicData);
  }
  return b64Lite.toBase64(
    [handle, generateToken(TOKEN_LENGTH), hash256(publicDataString), index.SESSION_TOKEN_VERSION_0].join(
      index.TOKEN_SEPARATOR
    )
  );
};
const parseSessionToken = (token) => {
  const [handle, id, hashedPublicData, version] = b64Lite.fromBase64(token).split(index.TOKEN_SEPARATOR);
  if (!handle || !id || !hashedPublicData || !version) {
    throw new blitz.AuthenticationError("Failed to parse session token");
  }
  return {
    handle,
    id,
    hashedPublicData,
    version
  };
};
const createPublicDataToken = (publicData) => {
  const payload = typeof publicData === "string" ? publicData : JSON.stringify(publicData);
  return b64Lite.toBase64(payload);
};
const createAntiCSRFToken = () => generateToken(TOKEN_LENGTH);
const getSessionSecretKey = () => {
  if (process.env.NODE_ENV === "production") {
    if (!process.env.SESSION_SECRET_KEY && process.env.SECRET_SESSION_KEY) {
      throw new Error(
        "You need to rename the SECRET_SESSION_KEY environment variable to SESSION_SECRET_KEY (but don't feel bad, we've all done it :)"
      );
    }
    blitz.assert(
      process.env.SESSION_SECRET_KEY,
      "You must provide the SESSION_SECRET_KEY environment variable in production. This is used to sign and verify tokens. It should be 32 chars long."
    );
    blitz.assert(
      process.env.SESSION_SECRET_KEY.length >= 32,
      "The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security"
    );
    return process.env.SESSION_SECRET_KEY;
  } else {
    return process.env.SESSION_SECRET_KEY || "default-dev-secret";
  }
};
const JWT_NAMESPACE = "blitzjs";
const JWT_ISSUER = "blitzjs";
const JWT_AUDIENCE = "blitzjs";
const JWT_ANONYMOUS_SUBJECT = "anonymous";
const JWT_ALGORITHM = "HS256";
const createAnonymousSessionToken = (payload) => {
  return jsonwebtoken.sign({ [JWT_NAMESPACE]: payload }, getSessionSecretKey() || "", {
    algorithm: JWT_ALGORITHM,
    issuer: JWT_ISSUER,
    audience: JWT_AUDIENCE,
    subject: JWT_ANONYMOUS_SUBJECT
  });
};
const parseAnonymousSessionToken = (token) => {
  const secret = getSessionSecretKey();
  try {
    const fullPayload = jsonwebtoken.verify(token, secret, {
      algorithms: [JWT_ALGORITHM],
      issuer: JWT_ISSUER,
      audience: JWT_AUDIENCE,
      subject: JWT_ANONYMOUS_SUBJECT
    });
    if (typeof fullPayload === "object") {
      return fullPayload[JWT_NAMESPACE];
    } else {
      return null;
    }
  } catch (error) {
    return null;
  }
};
const setCookie = (res, cookieStr) => {
  const getCookieName = (c) => c.split("=", 2)[0];
  const appendCookie = () => append(res, "Set-Cookie", cookieStr);
  const cookiesHeader = res.getHeader("Set-Cookie");
  const cookieName = getCookieName(cookieStr);
  if (typeof cookiesHeader !== "string" && !Array.isArray(cookiesHeader)) {
    appendCookie();
    return;
  }
  if (typeof cookiesHeader === "string") {
    if (cookieName === getCookieName(cookiesHeader)) {
      res.setHeader("Set-Cookie", cookieStr);
    } else {
      appendCookie();
    }
  } else {
    for (let i = 0; i < cookiesHeader.length; i++) {
      if (cookieName === getCookieName(cookiesHeader[i] || "")) {
        cookiesHeader[i] = cookieStr;
        res.setHeader("Set-Cookie", cookiesHeader);
        return;
      }
    }
    appendCookie();
  }
};
const setHeader = (res, name, value) => {
  res.setHeader(name, value);
  if ("_blitz" in res) {
    res._blitz[name] = value;
  }
};
const setSessionCookie = (req, res, sessionToken, expiresAt) => {
  setCookie(
    res,
    cookie__default.serialize(index.COOKIE_SESSION_TOKEN(), sessionToken, {
      path: "/",
      httpOnly: true,
      secure: global.sessionConfig.secureCookies && !isLocalhost(req),
      sameSite: global.sessionConfig.sameSite,
      domain: global.sessionConfig.domain,
      expires: expiresAt
    })
  );
};
const setAnonymousSessionCookie = (req, res, token, expiresAt) => {
  setCookie(
    res,
    cookie__default.serialize(index.COOKIE_ANONYMOUS_SESSION_TOKEN(), token, {
      path: "/",
      httpOnly: true,
      secure: global.sessionConfig.secureCookies && !isLocalhost(req),
      sameSite: global.sessionConfig.sameSite,
      domain: global.sessionConfig.domain,
      expires: expiresAt
    })
  );
};
const setCSRFCookie = (req, res, antiCSRFToken, expiresAt) => {
  debug("setCSRFCookie", antiCSRFToken);
  blitz.assert(antiCSRFToken !== void 0, "Internal error: antiCSRFToken is being set to undefined");
  setCookie(
    res,
    cookie__default.serialize(index.COOKIE_CSRF_TOKEN(), antiCSRFToken, {
      path: "/",
      secure: global.sessionConfig.secureCookies && !isLocalhost(req),
      sameSite: global.sessionConfig.sameSite,
      domain: global.sessionConfig.domain,
      expires: expiresAt
    })
  );
};
const setPublicDataCookie = (req, res, publicDataToken, expiresAt) => {
  setHeader(res, index.HEADER_PUBLIC_DATA_TOKEN, "updated");
  setCookie(
    res,
    cookie__default.serialize(index.COOKIE_PUBLIC_DATA_TOKEN(), publicDataToken, {
      path: "/",
      secure: global.sessionConfig.secureCookies && !isLocalhost(req),
      sameSite: global.sessionConfig.sameSite,
      domain: global.sessionConfig.domain,
      expires: expiresAt
    })
  );
};
function getSessionKernel(req, res) {
  return __async$2(this, null, function* () {
    var _a;
    const anonymousSessionToken = req.cookies[index.COOKIE_ANONYMOUS_SESSION_TOKEN()];
    const sessionToken = req.cookies[index.COOKIE_SESSION_TOKEN()];
    const idRefreshToken = req.cookies[index.COOKIE_REFRESH_TOKEN()];
    const enableCsrfProtection = req.method !== "GET" && req.method !== "OPTIONS" && req.method !== "HEAD" && !process.env.DANGEROUSLY_DISABLE_CSRF_PROTECTION;
    const antiCSRFToken = req.headers[index.HEADER_CSRF];
    if (sessionToken) {
      debug("[getSessionKernel] Request has sessionToken");
      const { handle, version, hashedPublicData } = parseSessionToken(sessionToken);
      if (!handle) {
        debug("No handle in sessionToken");
        return null;
      }
      if (version !== index.SESSION_TOKEN_VERSION_0) {
        console.log(
          new blitz.AuthenticationError("Session token version is not " + index.SESSION_TOKEN_VERSION_0)
        );
        return null;
      }
      debug("(global as any) session config", global.sessionConfig);
      const persistedSession = yield global.sessionConfig.getSession(handle);
      if (!persistedSession) {
        debug("Session not found in DB");
        return null;
      }
      if (!persistedSession.antiCSRFToken) {
        throw new Error("Internal error: persistedSession.antiCSRFToken is empty");
      }
      if (persistedSession.hashedSessionToken !== hash256(sessionToken)) {
        debug("sessionToken hash did not match");
        debug("persisted: ", persistedSession.hashedSessionToken);
        debug("in req: ", hash256(sessionToken));
        return null;
      }
      if (persistedSession.expiresAt && blitz.isPast(persistedSession.expiresAt)) {
        debug("Session expired");
        return null;
      }
      if (enableCsrfProtection && persistedSession.antiCSRFToken !== antiCSRFToken) {
        if (!antiCSRFToken) {
          console.warn(
            `This request is missing the ${index.HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`
          );
        }
        setHeader(res, index.HEADER_CSRF_ERROR, "true");
        throw new blitz.CSRFTokenMismatchError();
      }
      if (req.method !== "GET") {
        const hasPublicDataChanged = hash256((_a = persistedSession.publicData) != null ? _a : void 0) !== hashedPublicData;
        if (hasPublicDataChanged) {
          debug("PublicData has changed since the last request");
        }
        const hasQuarterExpiryTimePassed = persistedSession.expiresAt && blitz.differenceInMinutes(persistedSession.expiresAt, new Date()) < 0.75 * global.sessionConfig.sessionExpiryMinutes;
        if (hasQuarterExpiryTimePassed) {
          debug("quarter expiry time has passed");
          debug("Persisted expire time", persistedSession.expiresAt);
        }
        if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {
          yield refreshSession(
            req,
            res,
            {
              handle,
              publicData: JSON.parse(persistedSession.publicData || ""),
              jwtPayload: null,
              antiCSRFToken: persistedSession.antiCSRFToken,
              sessionToken
            },
            { publicDataChanged: hasPublicDataChanged }
          );
        }
      }
      return {
        handle,
        publicData: JSON.parse(persistedSession.publicData || ""),
        jwtPayload: null,
        antiCSRFToken: persistedSession.antiCSRFToken,
        sessionToken
      };
    } else if (idRefreshToken) {
      return null;
    } else if (anonymousSessionToken) {
      debug("Request has anonymousSessionToken");
      const payload = parseAnonymousSessionToken(anonymousSessionToken);
      if (!payload) {
        debug("Payload empty");
        return null;
      }
      if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {
        if (!antiCSRFToken) {
          console.warn(
            `This request is missing the ${index.HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`
          );
        }
        setHeader(res, index.HEADER_CSRF_ERROR, "true");
        throw new blitz.CSRFTokenMismatchError();
      }
      return {
        handle: payload.handle,
        publicData: payload.publicData,
        antiCSRFToken: payload.antiCSRFToken,
        jwtPayload: payload,
        anonymousSessionToken
      };
    }
    return null;
  });
}
function createNewSession(args) {
  return __async$2(this, null, function* () {
    var _a, _b;
    const { req, res } = args;
    blitz.assert(args.publicData.userId !== void 0, "You must provide publicData.userId");
    const antiCSRFToken = createAntiCSRFToken();
    if (args.anonymous) {
      debug("Creating new anonymous session");
      const handle = generateAnonymousSessionHandle();
      const payload = {
        isAnonymous: true,
        handle,
        publicData: args.publicData,
        antiCSRFToken
      };
      const anonymousSessionToken = createAnonymousSessionToken(payload);
      const publicDataToken = createPublicDataToken(args.publicData);
      const expiresAt = blitz.addMinutes(
        new Date(),
        global.sessionConfig.anonSessionExpiryMinutes
      );
      setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt);
      setCSRFCookie(req, res, antiCSRFToken, expiresAt);
      setPublicDataCookie(req, res, publicDataToken, expiresAt);
      setSessionCookie(req, res, "", new Date(0));
      setHeader(res, index.HEADER_SESSION_CREATED, "true");
      return {
        handle,
        publicData: args.publicData,
        jwtPayload: payload,
        antiCSRFToken,
        anonymousSessionToken
      };
    } else if (global.sessionConfig.method === "essential") {
      debug("Creating new session");
      const newPublicData = __spreadValues$2(__spreadValues$2({}, ((_a = args.jwtPayload) == null ? void 0 : _a.publicData) || {}), args.publicData);
      blitz.assert(newPublicData.userId, "You must provide a non-empty userId as publicData.userId");
      let existingPrivateData = {};
      if ((_b = args.jwtPayload) == null ? void 0 : _b.isAnonymous) {
        const session = yield global.sessionConfig.getSession(args.jwtPayload.handle);
        if (session) {
          if (session.privateData) {
            existingPrivateData = JSON.parse(session.privateData);
          }
          yield global.sessionConfig.deleteSession(args.jwtPayload.handle);
        }
      }
      const newPrivateData = __spreadValues$2(__spreadValues$2({}, existingPrivateData), args.privateData);
      const expiresAt = blitz.addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
      const handle = generateEssentialSessionHandle();
      const sessionToken = createSessionToken(handle, newPublicData);
      const publicDataToken = createPublicDataToken(newPublicData);
      yield global.sessionConfig.createSession({
        expiresAt,
        handle,
        userId: newPublicData.userId,
        hashedSessionToken: hash256(sessionToken),
        antiCSRFToken,
        publicData: JSON.stringify(newPublicData),
        privateData: JSON.stringify(newPrivateData)
      });
      setSessionCookie(req, res, sessionToken, expiresAt);
      setCSRFCookie(req, res, antiCSRFToken, expiresAt);
      setPublicDataCookie(req, res, publicDataToken, expiresAt);
      setAnonymousSessionCookie(req, res, "", new Date(0));
      setHeader(res, index.HEADER_SESSION_CREATED, "true");
      return {
        handle,
        publicData: newPublicData,
        jwtPayload: null,
        antiCSRFToken,
        sessionToken
      };
    } else if (global.sessionConfig.method === "advanced") {
      throw new Error("The advanced method is not yet supported");
    } else {
      throw new Error(
        `Session management method ${global.sessionConfig.method} is invalid. Supported methods are "essential" and "advanced"`
      );
    }
  });
}
function createAnonymousSession(req, res) {
  return __async$2(this, null, function* () {
    return yield createNewSession({
      req,
      res,
      publicData: { userId: null },
      anonymous: true
    });
  });
}
function refreshSession(_0, _1, _2, _3) {
  return __async$2(this, arguments, function* (req, res, sessionKernel, { publicDataChanged }) {
    var _a;
    debug("Refreshing session", sessionKernel);
    if ((_a = sessionKernel.jwtPayload) == null ? void 0 : _a.isAnonymous) {
      const payload = __spreadProps$1(__spreadValues$2({}, sessionKernel.jwtPayload), {
        publicData: sessionKernel.publicData
      });
      const anonymousSessionToken = createAnonymousSessionToken(payload);
      const publicDataToken = createPublicDataToken(sessionKernel.publicData);
      const expiresAt = blitz.addYears(new Date(), 30);
      setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt);
      setPublicDataCookie(req, res, publicDataToken, expiresAt);
    } else if (global.sessionConfig.method === "essential" && "sessionToken" in sessionKernel) {
      const expiresAt = blitz.addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
      debug("Updating session in db with", { expiresAt });
      if (publicDataChanged) {
        debug("Public data has changed");
        const publicDataToken = createPublicDataToken(sessionKernel.publicData);
        setPublicDataCookie(req, res, publicDataToken, expiresAt);
        yield global.sessionConfig.updateSession(sessionKernel.handle, {
          expiresAt,
          publicData: JSON.stringify(sessionKernel.publicData)
        });
      } else {
        yield global.sessionConfig.updateSession(sessionKernel.handle, {
          expiresAt
        });
      }
    } else if (global.sessionConfig.method === "advanced") {
      throw new Error("refreshSession() not implemented for advanced method");
    }
  });
}
function getAllSessionHandlesForUser(userId) {
  return __async$2(this, null, function* () {
    return (yield global.sessionConfig.getSessions(userId)).map((session) => session.handle);
  });
}
function syncPubicDataFieldsForUserIfNeeded(userId, data) {
  return __async$2(this, null, function* () {
    var _a;
    const dataToSync = {};
    (_a = global.sessionConfig.publicDataKeysToSyncAcrossSessions) == null ? void 0 : _a.forEach((key) => {
      if (data[key]) {
        dataToSync[key] = data[key];
      }
    });
    if (Object.keys(dataToSync).length) {
      const sessions = yield global.sessionConfig.getSessions(userId);
      for (const session of sessions) {
        const publicData = JSON.stringify(__spreadValues$2(__spreadValues$2({}, session.publicData ? JSON.parse(session.publicData) : {}), dataToSync));
        yield global.sessionConfig.updateSession(session.handle, { publicData });
      }
    }
  });
}
function revokeSession(req, res, handle, anonymous = false) {
  return __async$2(this, null, function* () {
    debug("Revoking session", handle);
    if (!anonymous) {
      try {
        yield global.sessionConfig.deleteSession(handle);
      } catch (error) {
      }
    }
    return createAnonymousSession(req, res);
  });
}
function revokeAllSessionsForUser(userId) {
  return __async$2(this, null, function* () {
    let sessionHandles = (yield global.sessionConfig.getSessions(userId)).map(
      (session) => session.handle
    );
    let revoked = [];
    for (const handle of sessionHandles) {
      try {
        yield global.sessionConfig.deleteSession(handle);
      } catch (error) {
      }
      revoked.push(handle);
    }
    return revoked;
  });
}
function getPublicData(sessionKernel) {
  return __async$2(this, null, function* () {
    var _a, _b;
    if ((_a = sessionKernel.jwtPayload) == null ? void 0 : _a.publicData) {
      return (_b = sessionKernel.jwtPayload) == null ? void 0 : _b.publicData;
    } else {
      const session = yield global.sessionConfig.getSession(sessionKernel.handle);
      if (!session) {
        throw new Error("getPublicData() failed because handle doesn't exist " + sessionKernel.handle);
      }
      if (session.publicData) {
        return JSON.parse(session.publicData);
      } else {
        return {};
      }
    }
  });
}
function getPrivateData(handle) {
  return __async$2(this, null, function* () {
    const session = yield global.sessionConfig.getSession(handle);
    if (session && session.privateData) {
      return JSON.parse(session.privateData);
    } else {
      return null;
    }
  });
}
function setPrivateData(sessionKernel, data) {
  return __async$2(this, null, function* () {
    let existingPrivateData = yield getPrivateData(sessionKernel.handle);
    if (existingPrivateData === null) {
      try {
        yield global.sessionConfig.createSession({
          handle: sessionKernel.handle
        });
      } catch (error) {
      }
      existingPrivateData = {};
    }
    const privateData = JSON.stringify(__spreadValues$2(__spreadValues$2({}, existingPrivateData), data));
    yield global.sessionConfig.updateSession(sessionKernel.handle, {
      privateData
    });
  });
}
function setPublicData(req, res, sessionKernel, data) {
  return __async$2(this, null, function* () {
    delete data.userId;
    const publicData = __spreadValues$2(__spreadValues$2({}, yield getPublicData(sessionKernel)), data);
    yield refreshSession(req, res, __spreadProps$1(__spreadValues$2({}, sessionKernel), { publicData }), { publicDataChanged: true });
    return publicData;
  });
}
function setPublicDataForUser(userId, data) {
  return __async$2(this, null, function* () {
    delete data.userId;
    const sessions = yield global.sessionConfig.getSessions(userId);
    for (const session of sessions) {
      const publicData = JSON.stringify(__spreadValues$2(__spreadValues$2({}, JSON.parse(session.publicData || "")), data));
      yield global.sessionConfig.updateSession(session.handle, { publicData });
    }
  });
}
function append(res, field, val) {
  let prev = res.getHeader(field);
  let value = val;
  if (prev !== void 0) {
    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }
  value = Array.isArray(value) ? value.map(String) : String(value);
  res.setHeader(field, value);
  return res;
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const PrismaStorage = (db) => {
  return {
    getSession: (handle) => db.session.findFirst({ where: { handle } }),
    getSessions: (userId) => db.session.findMany({ where: { userId } }),
    createSession: (session) => {
      let user;
      if (session.userId) {
        user = { connect: { id: session.userId } };
      }
      return db.session.create({
        data: __spreadProps(__spreadValues$1({}, session), { userId: void 0, user })
      });
    },
    updateSession: (handle, session) => __async$1(void 0, null, function* () {
      try {
        return yield db.session.update({ where: { handle }, data: session });
      } catch (error) {
        if (error.code === "P2016") {
          console.warn("Could not update session because it's not in the DB");
        } else {
          throw error;
        }
      }
    }),
    deleteSession: (handle) => db.session.delete({ where: { handle } })
  };
};
const defaultConfig_ = {
  sessionExpiryMinutes: 30 * 24 * 60,
  anonSessionExpiryMinutes: 5 * 365 * 24 * 60,
  method: "essential",
  sameSite: "lax",
  publicDataKeysToSyncAcrossSessions: ["role", "roles"],
  secureCookies: !process.env.DISABLE_SECURE_COOKIES && process.env.NODE_ENV === "production"
};
function AuthServerPlugin(options) {
  globalThis.__BLITZ_SESSION_COOKIE_PREFIX = options.cookiePrefix || "blitz";
  function authPluginSessionMiddleware() {
    var _a;
    blitz.assert(
      options.isAuthorized,
      "You must provide an authorization implementation to sessionMiddleware as isAuthorized(userRoles, input)"
    );
    global.sessionConfig = __spreadValues$1(__spreadValues$1(__spreadValues$1({}, defaultConfig_), options.storage), options);
    const cookiePrefix = (_a = global.sessionConfig.cookiePrefix) != null ? _a : "blitz";
    blitz.assert(
      cookiePrefix.match(/^[a-zA-Z0-9-_]+$/),
      `The cookie prefix used has invalid characters. Only alphanumeric characters, "-"  and "_" character are supported`
    );
    const blitzSessionMiddleware = (req, res, next) => __async$1(this, null, function* () {
      var _a2;
      if (!((_a2 = res.blitzCtx) == null ? void 0 : _a2.session)) {
        yield getSession(req, res);
      }
      return next();
    });
    blitzSessionMiddleware.config = {
      name: "blitzSessionMiddleware",
      cookiePrefix
    };
    return blitzSessionMiddleware;
  }
  return {
    requestMiddlewares: [authPluginSessionMiddleware()]
  };
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const isFunction = (functionToCheck) => typeof functionToCheck === "function";
const isVerifyCallbackResult = (value) => typeof value === "object" && value !== null && "publicData" in value;
const INTERNAL_REDIRECT_URL_KEY = "_redirectUrl";
function passportAuth(config) {
  return function authHandler(req, res) {
    return __async(this, null, function* () {
      const configObject = isFunction(config) ? config({ ctx: res.blitzCtx, req, res }) : config;
      const cookieSessionMiddleware = cookieSession__default({
        secret: process.env.SESSION_SECRET_KEY || "default-dev-secret",
        secure: process.env.NODE_ENV === "production" && !isLocalhost(req)
      });
      const passportMiddleware = passport__default.initialize();
      const middleware = [
        blitz.connectMiddleware(cookieSessionMiddleware),
        blitz.connectMiddleware(passportMiddleware),
        blitz.connectMiddleware(passport__default.session())
      ];
      if (configObject.secureProxy) {
        middleware.push(blitz.secureProxyMiddleware);
      }
      blitz.assert(
        req.query.auth,
        "req.query.auth is not defined. Page must be named [...auth].ts/js. See more at https://blitzjs.com/docs/passportjs#1-add-the-passport-js-api-route"
      );
      blitz.assert(
        Array.isArray(req.query.auth),
        "req.query.auth must be an array. Page must be named [...auth].ts/js. See more at https://blitzjs.com/docs/passportjs#1-add-the-passport-js-api-route"
      );
      if (!req.query.auth.length) {
        return res.status(404).end();
      }
      blitz.assert(
        configObject.strategies.length,
        "No Passport strategies found! Please add at least one strategy."
      );
      const blitzStrategy = configObject.strategies.find(
        ({ name: name2, strategy: strategy2 }) => {
          var _a, _b, _c, _d;
          return name2 ? name2 == ((_b = (_a = req.query) == null ? void 0 : _a.auth) == null ? void 0 : _b[0]) : strategy2.name === ((_d = (_c = req.query) == null ? void 0 : _c.auth) == null ? void 0 : _d[0]);
        }
      );
      blitz.assert(blitzStrategy, `A passport strategy was not found for: ${req.query.auth[0]}`);
      const { name, strategy, authenticateOptions } = blitzStrategy;
      blitz.assert(typeof strategy.name !== "undefined", `A passport strategy name was not found for: ${req.query.auth[0]}`);
      const strategyName = name || strategy.name;
      passport__default.use(strategyName, strategy);
      if (req.query.auth.length === 1) {
        console.info(`Starting authentication via ${strategyName}...`);
        if (req.query.redirectUrl) {
          middleware.push((req2, res2, next) => __async(this, null, function* () {
            const session = res2.blitzCtx.session;
            blitz.assert(session, "Missing Blitz sessionMiddleware!");
            yield session.$setPublicData({
              [INTERNAL_REDIRECT_URL_KEY]: req2.query.redirectUrl
            });
            return next();
          }));
        }
        middleware.push(
          blitz.connectMiddleware(passport__default.authenticate(strategyName, __spreadValues({}, authenticateOptions)))
        );
      } else if (req.query.auth[1] === "callback") {
        console.info(`Processing callback for ${strategyName}...`);
        middleware.push(
          blitz.connectMiddleware((req2, res2, next) => {
            const session = res2.blitzCtx.session;
            blitz.assert(session, "Missing Blitz sessionMiddleware!");
            passport__default.authenticate(strategyName, (err, result) => __async(this, null, function* () {
              try {
                let error = err;
                if (!error && result === false) {
                  console.warn(
                    `Login via ${strategyName} failed - usually this means the user did not authenticate properly with the provider`
                  );
                  error = `Login failed`;
                }
                const redirectUrlFromVerifyResult = result && typeof result === "object" && result.redirectUrl;
                let redirectUrl = redirectUrlFromVerifyResult || session.$publicData[INTERNAL_REDIRECT_URL_KEY] || (error ? configObject.errorRedirectUrl : configObject.successRedirectUrl) || "/";
                if (error) {
                  console.error(`Login via ${strategyName} was unsuccessful.`);
                  console.error(error);
                  redirectUrl += "?authError=" + encodeURIComponent(blitz.truncateString(error.toString(), 100));
                  res2.setHeader("Location", redirectUrl);
                  res2.statusCode = 302;
                  res2.end();
                  return;
                }
                blitz.assert(
                  typeof result === "object" && result !== null,
                  `Your '${strategyName}' passport verify callback returned empty data. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)`
                );
                blitz.assert(
                  result.publicData,
                  `'publicData' is missing from your '${strategyName}' passport verify callback. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)`
                );
                blitz.assert(isVerifyCallbackResult(result), "Passport verify callback is invalid");
                delete result.publicData[INTERNAL_REDIRECT_URL_KEY];
                yield session.$create(result.publicData, result.privateData);
                res2.setHeader("Location", redirectUrl);
                res2.statusCode = 302;
                res2.end();
              } catch (error) {
                console.error(error);
                res2.statusCode = 500;
                res2.end();
              }
            }))(req2, res2, next);
          })
        );
      }
      yield blitz.handleRequestWithMiddleware(
        req,
        res,
        middleware
      );
    });
  };
}

exports.AuthClientPlugin = index.AuthClientPlugin;
exports.COOKIE_ANONYMOUS_SESSION_TOKEN = index.COOKIE_ANONYMOUS_SESSION_TOKEN;
exports.COOKIE_CSRF_TOKEN = index.COOKIE_CSRF_TOKEN;
exports.COOKIE_PUBLIC_DATA_TOKEN = index.COOKIE_PUBLIC_DATA_TOKEN;
exports.COOKIE_REFRESH_TOKEN = index.COOKIE_REFRESH_TOKEN;
exports.COOKIE_SESSION_TOKEN = index.COOKIE_SESSION_TOKEN;
exports.HANDLE_SEPARATOR = index.HANDLE_SEPARATOR;
exports.HEADER_CSRF = index.HEADER_CSRF;
exports.HEADER_CSRF_ERROR = index.HEADER_CSRF_ERROR;
exports.HEADER_PUBLIC_DATA_TOKEN = index.HEADER_PUBLIC_DATA_TOKEN;
exports.HEADER_SESSION_CREATED = index.HEADER_SESSION_CREATED;
exports.LOCALSTORAGE_CSRF_TOKEN = index.LOCALSTORAGE_CSRF_TOKEN;
exports.LOCALSTORAGE_PREFIX = index.LOCALSTORAGE_PREFIX;
exports.LOCALSTORAGE_PUBLIC_DATA_TOKEN = index.LOCALSTORAGE_PUBLIC_DATA_TOKEN;
exports.SESSION_TOKEN_VERSION_0 = index.SESSION_TOKEN_VERSION_0;
exports.SESSION_TYPE_ANONYMOUS_JWT = index.SESSION_TYPE_ANONYMOUS_JWT;
exports.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = index.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
exports.TOKEN_SEPARATOR = index.TOKEN_SEPARATOR;
exports.backupAntiCSRFTokenToLocalStorage = index.backupAntiCSRFTokenToLocalStorage;
exports.getAntiCSRFToken = index.getAntiCSRFToken;
exports.getAuthValues = index.getAuthValues;
exports.getPublicDataStore = index.getPublicDataStore;
exports.parsePublicDataToken = index.parsePublicDataToken;
exports.useAuthenticatedSession = index.useAuthenticatedSession;
exports.useAuthorize = index.useAuthorize;
exports.useAuthorizeIf = index.useAuthorizeIf;
exports.useRedirectAuthenticated = index.useRedirectAuthenticated;
exports.useSession = index.useSession;
exports.AuthServerPlugin = AuthServerPlugin;
exports.PrismaStorage = PrismaStorage;
exports.SecurePassword = SecurePassword;
exports.SessionContextClass = SessionContextClass;
exports.generateToken = generateToken;
exports.getAllSessionHandlesForUser = getAllSessionHandlesForUser;
exports.getCookieParser = getCookieParser;
exports.getSession = getSession;
exports.hash256 = hash256;
exports.isLocalhost = isLocalhost;
exports.passportAuth = passportAuth;
exports.setCookie = setCookie;
exports.setPublicDataForUser = setPublicDataForUser;
exports.simpleRolesIsAuthorized = simpleRolesIsAuthorized;
