'use strict';

const normalizeTrailingSlash = require('next/dist/client/normalize-trailing-slash');
const addBasePath = require('next/dist/client/add-base-path');
const superjson = require('superjson');
const blitz = require('blitz');
require('@tanstack/react-query');
const auth = require('@blitzjs/auth');

const requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
  let start = Date.now();
  return setTimeout(function() {
    cb({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};
const getQueryClient = () => globalThis.queryClient;
function isRpcClient(f) {
  return !!f._isRpcClient;
}
const getQueryCacheFunctions = (resolver, params) => ({
  setQueryData: (newData, opts = { refetch: true }) => {
    return setQueryData(resolver, params, newData, opts);
  }
});
const emptyQueryFn = (() => {
  const fn = () => new Promise(() => {
  });
  fn._isRpcClient = true;
  return fn;
})();
const isNotInUserTestEnvironment = () => {
  if (process.env.JEST_WORKER_ID === void 0)
    return true;
  if (process.env.BLITZ_TEST_ENVIRONMENT !== void 0)
    return true;
  return false;
};
const validateQueryFn = (queryFn) => {
  if (blitz.isClient && !isRpcClient(queryFn) && isNotInUserTestEnvironment()) {
    throw new Error(
      `Either the file path to your resolver is incorrect (must be in a "queries" or "mutations" folder that isn't nested inside "pages" or "api") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from "@tanstack/react-query").`
    );
  }
};
const sanitize = (type) => (queryFn) => {
  if (blitz.isServer)
    return queryFn;
  validateQueryFn(queryFn);
  const rpcClient = queryFn;
  const queryFnName = type === "mutation" ? "useMutation" : "useQuery";
  if (rpcClient._resolverType !== type && isNotInUserTestEnvironment()) {
    throw new Error(
      `"${queryFnName}" was expected to be called with a ${type} but was called with a "${rpcClient._resolverType}"`
    );
  }
  return rpcClient;
};
const sanitizeQuery = sanitize("query");
const sanitizeMutation = sanitize("mutation");
const getQueryKeyFromUrlAndParams = (url, ...params) => {
  const queryKey = [url];
  if (params.length === 1) {
    const param = params[0];
    queryKey.push(superjson.serialize(typeof param === "function" ? param() : param));
  }
  return queryKey;
};
function getQueryKey(resolver, ...params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryKey is missing the first argument - it must be a resolver function");
  }
  return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, ...params);
}
function getInfiniteQueryKey(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error(
      "getInfiniteQueryKey is missing the first argument - it must be a resolver function"
    );
  }
  const queryKey = getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, params);
  return [...queryKey, "infinite"];
}
const invalidateQuery = (resolver, ...params) => {
  if (typeof resolver === "undefined") {
    throw new Error(
      "invalidateQuery is missing the first argument - it must be a resolver function"
    );
  }
  const fullQueryKey = getQueryKey(resolver, ...params);
  return getQueryClient().invalidateQueries(fullQueryKey);
};
function setQueryData(resolver, params, newData, opts = { refetch: true }) {
  if (typeof resolver === "undefined") {
    throw new Error("setQueryData is missing the first argument - it must be a resolver function");
  }
  const queryKey = getQueryKey(resolver, params);
  return new Promise((res) => {
    getQueryClient().setQueryData(queryKey, newData);
    let result;
    if (opts.refetch) {
      result = invalidateQuery(resolver, params);
    }
    if (blitz.isClient) {
      requestIdleCallback(() => {
        res(result);
      });
    } else {
      res(result);
    }
  });
}
function getQueryData(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryData is missing the first argument - it must be a resolver function");
  }
  const queryKey = getQueryKey(resolver, params);
  return getQueryClient().getQueryData(queryKey);
}

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function normalizeApiRoute(path) {
  return normalizeTrailingSlash.normalizePathTrailingSlash(addBasePath.addBasePath(path));
}
function __internal_buildRpcClient({
  resolverName,
  resolverType,
  routePath,
  httpMethod
}) {
  const fullRoutePath = normalizeApiRoute("/api/rpc" + routePath);
  const routePathURL = new URL(fullRoutePath, window.location.origin);
  const httpClient = (_0, ..._1) => __async(this, [_0, ..._1], function* (params, opts = {}, signal = void 0) {
    const debug = (yield import('debug')).default("blitz:rpc");
    if (!opts.fromQueryHook && !opts.fromInvoke) {
      console.warn(
        "[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)"
      );
    }
    if (blitz.isServer) {
      return Promise.resolve();
    }
    debug("Starting request for", fullRoutePath, "with", params, "and", opts);
    const headers = {
      "Content-Type": "application/json"
    };
    const antiCSRFToken = auth.getAntiCSRFToken();
    if (antiCSRFToken) {
      debug("Adding antiCSRFToken cookie header", antiCSRFToken);
      headers[auth.HEADER_CSRF] = antiCSRFToken;
    } else {
      debug("No antiCSRFToken cookie found");
    }
    let serialized;
    if (opts.alreadySerialized) {
      serialized = params;
    } else {
      serialized = superjson.serialize(params);
    }
    if (httpMethod === "GET") {
      routePathURL.searchParams.set("params", superjson.stringify(serialized.json));
      routePathURL.searchParams.set("meta", superjson.stringify(serialized.meta));
    }
    const promise = window.fetch(routePathURL, {
      method: httpMethod,
      headers,
      credentials: "include",
      redirect: "follow",
      body: httpMethod === "POST" ? JSON.stringify({
        params: serialized.json,
        meta: {
          params: serialized.meta
        }
      }) : void 0,
      signal
    }).then((response) => __async(this, null, function* () {
      var _a, _b;
      debug("Received request for", routePath);
      if (response.headers) {
        auth.backupAntiCSRFTokenToLocalStorage();
        if (response.headers.get(auth.HEADER_PUBLIC_DATA_TOKEN)) {
          auth.getPublicDataStore().updateState();
          debug("Public data updated");
        }
        if (response.headers.get(auth.HEADER_SESSION_CREATED)) {
          debug("Session created");
          setTimeout(() => __async(this, null, function* () {
            debug("Invalidating react-query cache...");
            yield getQueryClient().cancelQueries();
            yield getQueryClient().resetQueries();
            getQueryClient().getMutationCache().clear();
          }), 100);
        }
        if (response.headers.get(auth.HEADER_CSRF_ERROR)) {
          const err = new blitz.CSRFTokenMismatchError();
          err.stack = null;
          throw err;
        }
      }
      if (!response.ok) {
        const error = new Error(response.statusText);
        error.statusCode = response.status;
        error.path = routePath;
        error.stack = null;
        throw error;
      } else {
        let payload;
        try {
          payload = yield response.json();
        } catch (error) {
          const err = new Error(`Failed to parse json from ${routePath}`);
          err.stack = null;
          throw err;
        }
        if (payload.error) {
          let error = superjson.deserialize({
            json: payload.error,
            meta: (_a = payload.meta) == null ? void 0 : _a.error
          });
          if (error.name === "AuthenticationError" && auth.getPublicDataStore().getData().userId) {
            auth.getPublicDataStore().clear();
          }
          const prismaError = error.message.match(/invalid.*prisma.*invocation/i);
          if (prismaError && !("code" in error)) {
            error = new Error(prismaError[0]);
            error.statusCode = 500;
          }
          error.stack = null;
          throw error;
        } else {
          const data = superjson.deserialize({
            json: payload.result,
            meta: (_b = payload.meta) == null ? void 0 : _b.result
          });
          if (!opts.fromQueryHook) {
            const queryKey = getQueryKeyFromUrlAndParams(routePath, params);
            getQueryClient().setQueryData(queryKey, data);
          }
          return data;
        }
      }
    }));
    return promise;
  });
  const rpcClient = httpClient;
  rpcClient._isRpcClient = true;
  rpcClient._resolverName = resolverName;
  rpcClient._resolverType = resolverType;
  rpcClient._routePath = fullRoutePath;
  return rpcClient;
}

exports.__internal_buildRpcClient = __internal_buildRpcClient;
exports.emptyQueryFn = emptyQueryFn;
exports.getInfiniteQueryKey = getInfiniteQueryKey;
exports.getQueryCacheFunctions = getQueryCacheFunctions;
exports.getQueryClient = getQueryClient;
exports.getQueryData = getQueryData;
exports.getQueryKey = getQueryKey;
exports.invalidateQuery = invalidateQuery;
exports.normalizeApiRoute = normalizeApiRoute;
exports.sanitizeMutation = sanitizeMutation;
exports.sanitizeQuery = sanitizeQuery;
exports.setQueryData = setQueryData;
