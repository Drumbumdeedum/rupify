'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const path = require('path');
const fs = require('fs');
const loaderUtils = require('./chunks/loader-utils.cjs');
require('blitz');

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function loader(input) {
  return __async(this, null, function* () {
    const compiler = this._compiler;
    const id = this.resource;
    const root = this._compiler.context;
    const rpcFolders = this.query.includeRPCFolders ? this.query.includeRPCFolders : [];
    const isSSR = compiler.name === "server";
    if (isSSR) {
      this.cacheable(false);
      const resolvers = yield collectResolvers(root, rpcFolders, ["ts", "js"]);
      return yield transformBlitzRpcServer(
        input,
        loaderUtils.toPosixPath(id),
        loaderUtils.toPosixPath(root),
        resolvers,
        this.query
      );
    }
    return input;
  });
}
module.exports = loader;
function slash(str) {
  return str.replace(/\\/g, "/");
}
function transformBlitzRpcServer(src, id, root, resolvers, options) {
  return __async(this, null, function* () {
    loaderUtils.assertPosixPath(id);
    loaderUtils.assertPosixPath(root);
    const blitzImport = 'import { __internal_addBlitzRpcResolver } from "@blitzjs/rpc";';
    let code = blitzImport + src;
    code += "\n\n";
    for (let resolverFilePath of resolvers) {
      const routePath = loaderUtils.convertPageFilePathToRoutePath({
        appRoot: root,
        absoluteFilePath: resolverFilePath,
        resolverBasePath: options == null ? void 0 : options.resolverPath,
        extraRpcBasePaths: options == null ? void 0 : options.includeRPCFolders
      });
      code += `__internal_addBlitzRpcResolver('${routePath}',() => import('${slash(
        resolverFilePath
      )}'));`;
      code += "\n";
    }
    return code;
  });
}
function collectResolvers(directory, rpcFolders, pageExtensions) {
  return recursiveFindResolvers(
    directory,
    loaderUtils.buildPageExtensionRegex(pageExtensions),
    void 0,
    [],
    directory,
    rpcFolders
  );
}
function recursiveFindResolvers(_0, _1, _2) {
  return __async(this, arguments, function* (dir, filter, ignore, arr = [], rootDir = dir, rpcFolders = []) {
    let folders = yield fs.promises.readdir(dir);
    if (dir === rootDir) {
      folders = folders.filter((folder) => loaderUtils.topLevelFoldersThatMayContainResolvers.includes(folder));
      folders.push(...rpcFolders);
    }
    yield Promise.all(
      folders.map((part) => __async(this, null, function* () {
        const absolutePath = path.join(dir, part);
        if (ignore && ignore.test(part))
          return;
        const pathStat = yield fs.promises.stat(absolutePath);
        if (pathStat.isDirectory()) {
          if (!absolutePath.includes("node_modules")) {
            yield recursiveFindResolvers(absolutePath, filter, ignore, arr, rootDir);
            return;
          }
        }
        if (!filter.test(part)) {
          return;
        }
        if (loaderUtils.getIsRpcFile(absolutePath)) {
          arr.push(absolutePath);
          return;
        }
      }))
    );
    return arr.sort();
  });
}

exports.collectResolvers = collectResolvers;
exports.loader = loader;
exports.recursiveFindResolvers = recursiveFindResolvers;
exports.transformBlitzRpcServer = transformBlitzRpcServer;
