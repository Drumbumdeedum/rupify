'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const blitz = require('blitz');
const reactQuery = require('@tanstack/react-query');
const rpc = require('./chunks/rpc.cjs');
const router = require('next/router');
require('next/dist/client/normalize-trailing-slash');
require('next/dist/client/add-base-path');
require('superjson');
require('@blitzjs/auth');

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useQuery(queryFn, params, options = {}) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("useQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = blitz.isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = router.useRouter().isReady || blitz.isServer && suspenseEnabled;
  const enhancedResolverRpcClient = rpc.sanitizeQuery(queryFn);
  const queryKey = rpc.getQueryKey(queryFn, params);
  const _b = reactQuery.useQuery(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ signal }) => enhancedResolverRpcClient(params, { fromQueryHook: true }, signal) : rpc.emptyQueryFn
  }, options), {
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && blitz.isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new Error();
    e.name = "Rendering Suspense fallback...";
    delete e.stack;
    throw e;
  }
  const rest = __spreadValues$1(__spreadValues$1({}, queryRest), rpc.getQueryCacheFunctions(queryFn, params));
  return [data, rest];
}
function usePaginatedQuery(queryFn, params, options = {}) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("usePaginatedQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = blitz.isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = router.useRouter().isReady || blitz.isServer && suspenseEnabled;
  const enhancedResolverRpcClient = rpc.sanitizeQuery(queryFn);
  const queryKey = rpc.getQueryKey(queryFn, params);
  const _b = reactQuery.useQuery(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ signal }) => enhancedResolverRpcClient(params, { fromQueryHook: true }, signal) : rpc.emptyQueryFn
  }, options), {
    keepPreviousData: true,
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && blitz.isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new Error();
    e.name = "Rendering Suspense fallback...";
    delete e.stack;
    throw e;
  }
  const rest = __spreadValues$1(__spreadValues$1({}, queryRest), rpc.getQueryCacheFunctions(queryFn, params));
  return [data, rest];
}
function useInfiniteQuery(queryFn, getQueryParams, options) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("useInfiniteQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = blitz.isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = router.useRouter().isReady || blitz.isServer && suspenseEnabled;
  const enhancedResolverRpcClient = rpc.sanitizeQuery(queryFn);
  const queryKey = rpc.getInfiniteQueryKey(queryFn, getQueryParams);
  const _b = reactQuery.useInfiniteQuery(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ pageParam, signal }) => enhancedResolverRpcClient(getQueryParams(pageParam), { fromQueryHook: true }, signal) : rpc.emptyQueryFn
  }, options), {
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && blitz.isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new Error();
    e.name = "Rendering Suspense fallback...";
    delete e.stack;
    throw e;
  }
  const rest = __spreadProps$1(__spreadValues$1(__spreadValues$1({}, queryRest), rpc.getQueryCacheFunctions(queryFn, getQueryParams)), {
    pageParams: data == null ? void 0 : data.pageParams
  });
  return [data == null ? void 0 : data.pages, rest];
}
function useMutation(mutationResolver, config) {
  const enhancedResolverRpcClient = rpc.sanitizeMutation(mutationResolver);
  const _a = reactQuery.useMutation(
    (variables) => enhancedResolverRpcClient(variables, { fromQueryHook: true }),
    __spreadValues$1({
      throwOnError: true
    }, config)
  ), { mutate, mutateAsync } = _a, rest = __objRest(_a, ["mutate", "mutateAsync"]);
  return [mutateAsync, rest];
}

function invoke(queryFn, params) {
  if (typeof queryFn === "undefined") {
    throw new Error(
      "invoke is missing the first argument - it must be a query or mutation function"
    );
  }
  if (blitz.isClient) {
    const fn = queryFn;
    return fn(params, { fromInvoke: true });
  } else {
    const fn = queryFn;
    return fn(params);
  }
}

function invokeWithCtx(queryFn, params, ctx) {
  if (typeof queryFn === "undefined") {
    throw new Error(
      "invokeWithCtx is missing the first argument - it must be a query or mutation function"
    );
  }
  return queryFn(params, ctx);
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const BlitzRpcPlugin = blitz.createClientPlugin(
  (options) => {
    const initializeQueryClient = () => {
      var _a, _b;
      const { reactQueryOptions } = options || {};
      let suspenseEnabled = (_b = (_a = reactQueryOptions == null ? void 0 : reactQueryOptions.queries) == null ? void 0 : _a.suspense) != null ? _b : true;
      if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
        globalThis.__BLITZ_SUSPENSE_ENABLED = suspenseEnabled;
      }
      return new reactQuery.QueryClient({
        defaultOptions: __spreadProps(__spreadValues({}, reactQueryOptions), {
          queries: __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, typeof window === "undefined" && { cacheTime: 0 }), {
            retry: (failureCount, error) => {
              if (process.env.NODE_ENV !== "production")
                return false;
              if (error.message === "Network request failed" && failureCount <= 3)
                return true;
              return false;
            }
          }), reactQueryOptions == null ? void 0 : reactQueryOptions.queries), {
            suspense: suspenseEnabled
          })
        })
      });
    };
    const queryClient = initializeQueryClient();
    globalThis.queryClient = queryClient;
    return {
      events: {},
      middleware: {},
      exports: () => ({
        queryClient
      })
    };
  }
);

exports.QueryClient = reactQuery.QueryClient;
exports.QueryClientProvider = reactQuery.QueryClientProvider;
exports.dehydrate = reactQuery.dehydrate;
exports.useQueryErrorResetBoundary = reactQuery.useQueryErrorResetBoundary;
exports.__internal_buildRpcClient = rpc.__internal_buildRpcClient;
exports.getInfiniteQueryKey = rpc.getInfiniteQueryKey;
exports.getQueryClient = rpc.getQueryClient;
exports.getQueryData = rpc.getQueryData;
exports.getQueryKey = rpc.getQueryKey;
exports.invalidateQuery = rpc.invalidateQuery;
exports.normalizeApiRoute = rpc.normalizeApiRoute;
exports.setQueryData = rpc.setQueryData;
exports.BlitzRpcPlugin = BlitzRpcPlugin;
exports.invoke = invoke;
exports.invokeWithCtx = invokeWithCtx;
exports.useInfiniteQuery = useInfiniteQuery;
exports.useMutation = useMutation;
exports.usePaginatedQuery = usePaginatedQuery;
exports.useQuery = useQuery;
