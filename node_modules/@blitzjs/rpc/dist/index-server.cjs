'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const blitz = require('blitz');
const superjson = require('superjson');
const path = require('path');
const chalk = require('chalk');
const indexBrowser = require('./index-browser.cjs');
const rpc = require('./chunks/rpc.cjs');
const reactQuery = require('@tanstack/react-query');
require('next/router');
require('next/dist/client/normalize-trailing-slash');
require('next/dist/client/add-base-path');
require('@blitzjs/auth');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isResultWithContext(x) {
  return typeof x === "object" && x !== null && "ctx" in x && x.__blitz === true;
}
function pipe(...args) {
  const functions = args;
  return function(input, ctx) {
    return __async$1(this, null, function* () {
      let lastResult = input;
      for (let fn of functions) {
        lastResult = yield fn(lastResult, ctx);
        if (isResultWithContext(lastResult)) {
          ctx = lastResult.ctx;
          lastResult = lastResult.value;
        }
      }
      return lastResult;
    });
  };
}
const authorize = (...args) => {
  return function _innerAuthorize(input, ctx) {
    const session = ctx.session;
    session.$authorize(...args);
    return {
      __blitz: true,
      value: input,
      ctx
    };
  };
};
function zod(schema, parserType = "async") {
  if (parserType === "sync") {
    return (input) => schema.parse(input);
  } else {
    return (input) => schema.parseAsync(input);
  }
}
const resolver = {
  pipe,
  zod,
  authorize
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const defaultConfig = {
  httpMethod: "POST"
};
function getGlobalObject(key, defaultValue) {
  blitz.assert(key.startsWith("__internal_blitz"), "unsupported key");
  if (typeof global === "undefined") {
    return defaultValue;
  }
  blitz.assert(isObject(global), "not an object");
  return global[key] = global[key] || defaultValue;
}
const g = getGlobalObject(
  "__internal_blitzRpcResolverFiles",
  {
    blitzRpcResolverFilesLoaded: null
  }
);
function loadBlitzRpcResolverFilesWithInternalMechanism() {
  return g.blitzRpcResolverFilesLoaded;
}
function __internal_addBlitzRpcResolver(routePath, resolver) {
  g.blitzRpcResolverFilesLoaded = g.blitzRpcResolverFilesLoaded || {};
  g.blitzRpcResolverFilesLoaded[routePath] = resolver;
  return resolver;
}
const dir = __dirname + (() => "")();
const loaderClient = path.resolve(dir, "./loader-client.cjs");
const loaderServer = path.resolve(dir, "./loader-server.cjs");
const loaderServerResolvers = path.resolve(dir, "./loader-server-resolvers.cjs");
function installWebpackConfig({
  webpackConfig,
  webpackRuleOptions
}) {
  webpackConfig.resolve.alias["npm-which"] = false;
  webpackConfig.resolve.alias["cross-spawn"] = false;
  webpackConfig.module.rules.push({
    test: /[\\/]\[\[\.\.\.blitz]]?.+\.[jt]sx?$/,
    use: [
      {
        loader: loaderServer,
        options: webpackRuleOptions
      }
    ]
  });
  webpackConfig.module.rules.push({
    test: /[\\/](queries|mutations)[\\/]/,
    use: [
      {
        loader: loaderClient,
        options: webpackRuleOptions
      },
      {
        loader: loaderServerResolvers,
        options: webpackRuleOptions
      }
    ]
  });
}
function getResolverMap() {
  return __async(this, null, function* () {
    {
      const resolverFilesLoaded = loadBlitzRpcResolverFilesWithInternalMechanism();
      if (resolverFilesLoaded) {
        return resolverFilesLoaded;
      }
    }
  });
}
function rpcHandler(config) {
  return function handleRpcRequest(req, res, ctx) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const resolverMap = yield getResolverMap();
      blitz.assert(resolverMap, "No query or mutation resolvers found");
      blitz.assert(
        Array.isArray(req.query.blitz),
        "It seems your Blitz RPC endpoint file is not named [[...blitz]].(jt)s. Please ensure it is"
      );
      const relativeRoutePath = (_a = req.query.blitz) == null ? void 0 : _a.join("/");
      const routePath = "/" + relativeRoutePath;
      const log = blitz.baseLogger().getChildLogger({
        prefix: [routePath.replace(/(\/api\/rpc)?\//, "") + "()"]
      });
      const customChalk = new chalk__default.Instance({
        level: log.settings.type === "json" ? 0 : chalk__default.level
      });
      const loadableResolver = resolverMap == null ? void 0 : resolverMap[routePath];
      if (!loadableResolver) {
        throw new Error("No resolver for path: " + routePath);
      }
      const { default: resolver, config: resolverConfig } = yield loadableResolver();
      if (!resolver) {
        throw new Error("No default export for resolver path: " + routePath);
      }
      const resolverConfigWithDefaults = __spreadValues(__spreadValues({}, defaultConfig), resolverConfig);
      if (req.method === "HEAD") {
        res.status(200).end();
        return;
      } else if (req.method === "POST" || req.method === "GET" && resolverConfigWithDefaults.httpMethod === "GET") {
        if (req.method === "GET") {
          if (Object.keys(req.query).length === 1 && req.query.blitz) {
            const error = { message: "Request query is missing the required `params` and `meta` keys" };
            log.error(error.message);
            res.status(400).json({
              result: null,
              error
            });
            return;
          }
        } else if (typeof req.body.params === "undefined") {
          const error = { message: "Request body is missing the `params` key" };
          log.error(error.message);
          res.status(400).json({
            result: null,
            error
          });
          return;
        }
        try {
          const data = superjson.deserialize({
            json: req.method === "POST" ? req.body.params : superjson.parse(`${req.query.params}`),
            meta: req.method === "POST" ? (_b = req.body.meta) == null ? void 0 : _b.params : superjson.parse(`${req.query.meta}`)
          });
          log.info(customChalk.dim("Starting with input:"), data ? data : JSON.stringify(data));
          const startTime = Date.now();
          const result = yield resolver(data, res.blitzCtx);
          const resolverDuration = Date.now() - startTime;
          log.debug(customChalk.dim("Result:"), result ? result : JSON.stringify(result));
          const serializerStartTime = Date.now();
          const serializedResult = superjson.serialize(result);
          const nextSerializerStartTime = Date.now();
          res.blitzResult = result;
          res.json({
            result: serializedResult.json,
            error: null,
            meta: {
              result: serializedResult.meta
            }
          });
          log.debug(
            customChalk.dim(
              `Next.js serialization:${blitz.prettyMs(Date.now() - nextSerializerStartTime)}`
            )
          );
          const serializerDuration = Date.now() - serializerStartTime;
          const duration = Date.now() - startTime;
          log.info(
            customChalk.dim(
              `Finished: resolver:${blitz.prettyMs(resolverDuration)} serializer:${blitz.prettyMs(
                serializerDuration
              )} total:${blitz.prettyMs(duration)}`
            )
          );
          blitz.newLine();
          return;
        } catch (error) {
          if (error._clearStack) {
            delete error.stack;
          }
          (_c = config.onError) == null ? void 0 : _c.call(config, error);
          log.error(error);
          blitz.newLine();
          if (!error.statusCode) {
            error.statusCode = 500;
          }
          const serializedError = superjson.serialize(error);
          res.json({
            result: null,
            error: serializedError.json,
            meta: {
              error: serializedError.meta
            }
          });
          return;
        }
      } else {
        log.warn(`${req.method} method not supported`);
        res.status(404).end();
        return;
      }
    });
  };
}

exports.BlitzRpcPlugin = indexBrowser.BlitzRpcPlugin;
exports.invoke = indexBrowser.invoke;
exports.invokeWithCtx = indexBrowser.invokeWithCtx;
exports.useInfiniteQuery = indexBrowser.useInfiniteQuery;
exports.useMutation = indexBrowser.useMutation;
exports.usePaginatedQuery = indexBrowser.usePaginatedQuery;
exports.useQuery = indexBrowser.useQuery;
exports.__internal_buildRpcClient = rpc.__internal_buildRpcClient;
exports.getInfiniteQueryKey = rpc.getInfiniteQueryKey;
exports.getQueryClient = rpc.getQueryClient;
exports.getQueryData = rpc.getQueryData;
exports.getQueryKey = rpc.getQueryKey;
exports.invalidateQuery = rpc.invalidateQuery;
exports.normalizeApiRoute = rpc.normalizeApiRoute;
exports.setQueryData = rpc.setQueryData;
exports.QueryClient = reactQuery.QueryClient;
exports.QueryClientProvider = reactQuery.QueryClientProvider;
exports.dehydrate = reactQuery.dehydrate;
exports.useQueryErrorResetBoundary = reactQuery.useQueryErrorResetBoundary;
exports.__internal_addBlitzRpcResolver = __internal_addBlitzRpcResolver;
exports.installWebpackConfig = installWebpackConfig;
exports.loadBlitzRpcResolverFilesWithInternalMechanism = loadBlitzRpcResolverFilesWithInternalMechanism;
exports.resolver = resolver;
exports.rpcHandler = rpcHandler;
