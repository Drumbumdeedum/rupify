import _SuperJson from 'superjson';
export { f as addMilliseconds, g as addMinutes, h as addYears, a as assert, k as compose, j as deleteCookie, d as differenceInMilliseconds, e as differenceInMinutes, l as interopDefault, b as isClient, c as isPast, i as isServer, p as prettyMs, r as readCookie, s as setCookie, t as truncateString } from './chunks/index.mjs';
import { spawn } from 'cross-spawn';
import which from 'npm-which';

const SuperJson = "default" in _SuperJson ? _SuperJson.default : _SuperJson;
const errorProps = ["name", "message", "code", "statusCode", "meta", "url"];
if (process.env.JEST_WORKER_ID === void 0) {
  SuperJson.allowErrorProps(...errorProps);
}
class AuthenticationError extends Error {
  constructor(message = "You must be logged in to access this") {
    super(message);
    this.name = "AuthenticationError";
    this.statusCode = 401;
  }
  get _clearStack() {
    return true;
  }
}
class CSRFTokenMismatchError extends Error {
  constructor() {
    super(...arguments);
    this.name = "CSRFTokenMismatchError";
    this.statusCode = 401;
  }
  get _clearStack() {
    return true;
  }
}
class AuthorizationError extends Error {
  constructor(message = "You are not authorized to access this") {
    super(message);
    this.name = "AuthorizationError";
    this.statusCode = 403;
  }
  get _clearStack() {
    return true;
  }
}
class NotFoundError extends Error {
  constructor(message = "This could not be found") {
    super(message);
    this.name = "NotFoundError";
    this.statusCode = 404;
  }
  get _clearStack() {
    return true;
  }
}
class RedirectError extends Error {
  constructor(url) {
    super(typeof url === "object" ? url.href : url);
    this.name = "RedirectError";
    this.statusCode = 302;
    this.url = url;
  }
  get _clearStack() {
    return true;
  }
}
class PaginationArgumentError extends Error {
  constructor(message = "The pagination arguments are invalid") {
    super(message);
    this.name = "PaginationArgumentError";
    this.statusCode = 422;
  }
}
if (process.env.JEST_WORKER_ID === void 0 && !globalThis._BLITZ_ERROR_CLASS_REGISTERED) {
  SuperJson.registerClass(AuthenticationError, {
    identifier: "BlitzAuthenticationError",
    allowProps: errorProps
  });
  SuperJson.registerClass(CSRFTokenMismatchError, {
    identifier: "BlitzCSRFTokenMismatchError",
    allowProps: errorProps
  });
  SuperJson.registerClass(AuthorizationError, {
    identifier: "BlitzAuthorizationError",
    allowProps: errorProps
  });
  SuperJson.registerClass(NotFoundError, {
    identifier: "BlitzNotFoundError",
    allowProps: errorProps
  });
  SuperJson.registerClass(RedirectError, {
    identifier: "BlitzRedirectError",
    allowProps: errorProps
  });
  SuperJson.registerClass(PaginationArgumentError, {
    identifier: "BlitzPaginationArgumentError",
    allowProps: errorProps
  });
  globalThis._BLITZ_ERROR_CLASS_REGISTERED = true;
}

const isRouteUrlObject = (x) => {
  return typeof x === "object" && "pathname" in x && typeof x.pathname === "string";
};

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const enhancePrisma = (client) => {
  return new Proxy(client, {
    construct(target, args) {
      if (typeof window !== "undefined" && process.env.JEST_WORKER_ID === void 0) {
        return { $use: () => {
        } };
      }
      if (!globalThis._blitz_prismaClient) {
        const client2 = new target(...args);
        client2.$reset = function reset() {
          return __async$1(this, null, function* () {
            if (process.env.NODE_ENV === "production") {
              throw new Error(
                "You are calling db.$reset() in a production environment. We think you probably didn't mean to do that, so we are throwing this error instead of destroying your life's work."
              );
            }
            const prismaBin = which(process.cwd()).sync("prisma");
            yield new Promise((res, rej) => {
              const process2 = spawn(prismaBin, ["migrate", "reset", "--force", "--skip-generate"], {
                stdio: "ignore"
              });
              process2.on("exit", (code) => code === 0 ? res(0) : rej(code));
            });
            globalThis._blitz_prismaClient.$disconnect();
          });
        };
        globalThis._blitz_prismaClient = client2;
      }
      return globalThis._blitz_prismaClient;
    }
  });
};

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function recursiveFormatZodErrors(errors) {
  var _a, _b;
  let formattedErrors = {};
  for (const key in errors) {
    if (key === "_errors") {
      continue;
    }
    if ((_b = (_a = errors[key]) == null ? void 0 : _a._errors) == null ? void 0 : _b[0]) {
      if (!isNaN(key) && !Array.isArray(formattedErrors)) {
        formattedErrors = [];
      }
      formattedErrors[key] = errors[key]._errors[0];
    } else {
      if (!isNaN(key) && !Array.isArray(formattedErrors)) {
        formattedErrors = [];
      }
      formattedErrors[key] = recursiveFormatZodErrors(errors[key]);
    }
  }
  return formattedErrors;
}
function formatZodError(error) {
  if (!error || typeof error.format !== "function") {
    throw new Error("The argument to formatZodError must be a zod error with error.format()");
  }
  const errors = error.format();
  return recursiveFormatZodErrors(errors);
}
const validateZodSchemaSync = (schema) => (values) => {
  if (!schema)
    return {};
  try {
    schema.parse(values);
    return {};
  } catch (error) {
    return error.format ? formatZodError(error) : error.toString();
  }
};
const validateZodSchemaAsync = (schema) => (values) => __async(void 0, null, function* () {
  if (!schema)
    return {};
  try {
    yield schema.parseAsync(values);
    return {};
  } catch (error) {
    return error.format ? formatZodError(error) : error.toString();
  }
});
function validateZodSchema(schema, parserType = "async") {
  if (parserType === "sync") {
    return validateZodSchemaSync(schema);
  } else {
    return validateZodSchemaAsync(schema);
  }
}

function createClientPlugin(pluginConstructor) {
  return pluginConstructor;
}
if (typeof window !== "undefined" && process.env.NODE_ENV === "development") {
  let onUnhandledError = function(ev) {
    if (ev.error instanceof RedirectError || ev.error instanceof AuthenticationError || ev.error instanceof AuthorizationError || ev.error instanceof NotFoundError) {
      ev.preventDefault();
    }
  };
  if (typeof window !== "undefined") {
    window.addEventListener("error", onUnhandledError);
    if ("Cypress" in window) {
      const cypressOnErrorFun = window.onerror;
      window.onerror = (message, source, lineno, colno, err) => {
        if (cypressOnErrorFun && !(err instanceof RedirectError || err instanceof AuthenticationError || err instanceof AuthorizationError || err instanceof NotFoundError)) {
          cypressOnErrorFun(message, source, lineno, colno, err);
        }
      };
    }
  }
}

export { AuthenticationError, AuthorizationError, CSRFTokenMismatchError, NotFoundError, PaginationArgumentError, RedirectError, createClientPlugin, enhancePrisma, formatZodError, isRouteUrlObject, recursiveFormatZodErrors, validateZodSchema };
