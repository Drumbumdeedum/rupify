'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const indexBrowser = require('./index-browser.cjs');
const runPrisma = require('./chunks/run-prisma.cjs');
require('p-event');
require('cross-spawn');
require('resolve-from');
require('npm-which');
const logging = require('./chunks/logging.cjs');
const routesManifest = require('./chunks/routes-manifest.cjs');
const index = require('./chunks/index.cjs');
require('superjson');
require('tslog');
require('chalk');
require('console-table-printer');
require('ora');
require('readline');
require('path');
require('os');
require('fs');
require('fs-extra');
require('find-up');
require('watchpack');
require('./chunks/helpers.cjs');

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function handleRequestWithMiddleware(_0, _1, _2) {
  return __async$1(this, arguments, function* (req, res, middleware, {
    throwOnError = true,
    stackPrintOnError = true
  } = {}) {
    if (!res.blitzCtx) {
      res.blitzCtx = {};
    }
    if (!res._blitz) {
      res._blitz = {};
    }
    let handler = index.compose(middleware);
    try {
      yield handler(req, res, (error) => {
        if (error) {
          throw error;
        }
      });
    } catch (error) {
      console.log("\n");
      if (res.writableFinished) {
        console.error(
          "Error occured in middleware after the response was already sent to the browser"
        );
      } else {
        console.error("Error while processing the request");
      }
      if (error._clearStack) {
        delete error.stack;
      }
      console.error(error);
      console.log("\n");
      if (throwOnError)
        throw error;
    }
  });
}
function noCallbackHandler(req, res, next, middleware) {
  middleware(req, res);
  return next();
}
function withCallbackHandler(req, res, next, middleware) {
  return new Promise((resolve, reject) => {
    middleware(req, res, (err) => {
      if (err)
        reject(err);
      else
        resolve(next());
    });
  });
}
function connectMiddleware(middleware) {
  const handler = middleware.length < 3 ? noCallbackHandler : withCallbackHandler;
  return function connectHandler(req, res, next) {
    return handler(req, res, next, middleware);
  };
}
const secureProxyMiddleware = function(req, _res, next) {
  req.protocol = "https";
  next();
};

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const isInteger = (value) => typeof value === "number" && value % 1 === 0;
function paginate(_0) {
  return __async(this, arguments, function* ({
    skip = 0,
    take = 0,
    maxTake = 250,
    count: countQuery,
    query
  }) {
    if (!isInteger(skip)) {
      throw new indexBrowser.PaginationArgumentError("`skip` argument must be a integer");
    }
    if (!isInteger(take)) {
      throw new indexBrowser.PaginationArgumentError("`take` argument must be a integer");
    }
    if (!isInteger(maxTake)) {
      throw new indexBrowser.PaginationArgumentError("`maxTake` argument must be a integer");
    }
    if (typeof countQuery !== "function") {
      throw new indexBrowser.PaginationArgumentError("`count` argument must be a function");
    }
    if (typeof query !== "function") {
      throw new indexBrowser.PaginationArgumentError("`query` argument must be a function");
    }
    if (skip < 0) {
      throw new indexBrowser.PaginationArgumentError("`skip` argument must be a positive number");
    }
    if (take < 0) {
      throw new indexBrowser.PaginationArgumentError("`take` argument must be a positive number");
    }
    if (take > maxTake) {
      throw new indexBrowser.PaginationArgumentError(
        "`take` argument must less than `maxTake` which is currently " + maxTake
      );
    }
    const [count, items] = yield Promise.all([countQuery(), query({ skip, take })]);
    const hasMore = skip + take < count;
    const nextPage = hasMore ? { take, skip: skip + take } : null;
    const pageCount = Math.floor((count + take - 1) / take);
    const from = skip + 1;
    const to = skip + take;
    return {
      items,
      nextPage,
      hasMore,
      pageCount,
      pageSize: take,
      from,
      to,
      count
    };
  });
}

function createServerPlugin(pluginConstructor) {
  return pluginConstructor;
}
function createSetupServer(setupServerConstructor) {
  return setupServerConstructor;
}
const BlitzServerMiddleware = (middleware) => ({
  requestMiddlewares: [middleware]
});

exports.AuthenticationError = indexBrowser.AuthenticationError;
exports.AuthorizationError = indexBrowser.AuthorizationError;
exports.CSRFTokenMismatchError = indexBrowser.CSRFTokenMismatchError;
exports.NotFoundError = indexBrowser.NotFoundError;
exports.PaginationArgumentError = indexBrowser.PaginationArgumentError;
exports.RedirectError = indexBrowser.RedirectError;
exports.createClientPlugin = indexBrowser.createClientPlugin;
exports.enhancePrisma = indexBrowser.enhancePrisma;
exports.formatZodError = indexBrowser.formatZodError;
exports.isRouteUrlObject = indexBrowser.isRouteUrlObject;
exports.recursiveFormatZodErrors = indexBrowser.recursiveFormatZodErrors;
exports.validateZodSchema = indexBrowser.validateZodSchema;
exports.runPrisma = runPrisma.runPrisma;
exports.BlitzLogger = logging.BlitzLogger;
exports.baseLogger = logging.baseLogger;
exports.chalk = logging.chalk;
exports.initializeLogger = logging.initializeLogger;
exports.log = logging.log;
exports.newLine = logging.newLine;
exports.table = logging.table;
exports.startWatcher = routesManifest.startWatcher;
exports.stopWatcher = routesManifest.stopWatcher;
exports.addMilliseconds = index.addMilliseconds;
exports.addMinutes = index.addMinutes;
exports.addYears = index.addYears;
exports.assert = index.assert;
exports.compose = index.compose;
exports.deleteCookie = index.deleteCookie;
exports.differenceInMilliseconds = index.differenceInMilliseconds;
exports.differenceInMinutes = index.differenceInMinutes;
exports.interopDefault = index.interopDefault;
exports.isClient = index.isClient;
exports.isPast = index.isPast;
exports.isServer = index.isServer;
exports.prettyMs = index.prettyMs;
exports.readCookie = index.readCookie;
exports.setCookie = index.setCookie;
exports.truncateString = index.truncateString;
exports.BlitzServerMiddleware = BlitzServerMiddleware;
exports.connectMiddleware = connectMiddleware;
exports.createServerPlugin = createServerPlugin;
exports.createSetupServer = createSetupServer;
exports.handleRequestWithMiddleware = handleRequestWithMiddleware;
exports.noCallbackHandler = noCallbackHandler;
exports.paginate = paginate;
exports.secureProxyMiddleware = secureProxyMiddleware;
exports.withCallbackHandler = withCallbackHandler;
