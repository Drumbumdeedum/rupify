import * as React from 'react';
import * as j from 'jscodeshift';
import j__default from 'jscodeshift';
import { ExpressionKind, CommentKind, TypeAnnotationKind, TSTypeAnnotationKind } from 'ast-types/gen/kinds';
import * as jscodeshift_src_Collection from 'jscodeshift/src/Collection';
import * as ast_types from 'ast-types';
import { Enum, Field, Generator, ModelAttribute, Model, Schema, Datasource } from '@mrleebo/prisma-ast';

interface RecipeMeta {
    name: string;
    description: string;
    owner: string;
    repoLink: string;
}
declare type RecipeCLIArgs = {
    [Key in string]?: string | true;
};
interface RecipeCLIFlags {
    yesToAll: boolean;
}
declare type Program = j.Collection<j.Program>;
/**
Matches a JSON object.
This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. Don't use this as a direct return type as the user would have to double-cast it: `jsonObject as unknown as CustomResponse`. Instead, you could extend your CustomResponse type from it to ensure your type only uses JSON-compatible types: `interface CustomResponse extends JsonObject { â€¦ }`.
@see https://github.com/sindresorhus/type-fest
*/
declare type JsonObject = {
    [Key in string]?: JsonValue;
};
/**
Matches a JSON array.
@see https://github.com/sindresorhus/type-fest
*/
declare type JsonArray = JsonValue[];
/**
Matches any valid JSON primitive value.
@see https://github.com/sindresorhus/type-fest
*/
declare type JsonPrimitive = string | number | boolean | null;
/**
Matches any valid JSON value.
@see https://github.com/sindresorhus/type-fest
*/
declare type JsonValue = JsonPrimitive | JsonObject | JsonArray;

interface ExecutorConfig$1 {
    successIcon?: string;
    stepId: string | number;
    stepName: string;
    stepType: string;
    explanation: string;
}
interface IExecutor {
    type: string;
    Propose?: React.FC<{
        step: ExecutorConfig$1;
        onProposalAccepted: (data?: any) => void;
        cliArgs: RecipeCLIArgs;
        cliFlags: RecipeCLIFlags;
    }>;
    Commit: React.FC<{
        step: ExecutorConfig$1;
        proposalData?: any;
        onChangeCommitted: (data?: any) => void;
        cliArgs: RecipeCLIArgs;
        cliFlags: RecipeCLIFlags;
    }>;
}
declare type dynamicExecutorArgument<T> = (cliArgs: RecipeCLIArgs) => T;
declare type executorArgument<T> = T | dynamicExecutorArgument<T>;
declare function Frontmatter({ executor }: {
    executor: ExecutorConfig$1;
}): JSX.Element;
declare function getExecutorArgument<T>(input: executorArgument<T>, cliArgs: RecipeCLIArgs): T;

interface NpmPackage {
    name: string;
    version?: string;
    isDevDep?: boolean;
}
interface Config$4 extends ExecutorConfig$1 {
    packages: executorArgument<NpmPackage[]>;
}
declare const type$3 = "add-dependency";

declare const customTsParser: {};
declare type StringTransformer = (program: string) => string | Promise<string>;
declare type Transformer = (program: Program) => Program | Promise<Program>;

interface Config$3 extends ExecutorConfig$1 {
    selectTargetFiles?(cliArgs: RecipeCLIArgs): any[];
    singleFileSearch?: executorArgument<string>;
    transform?: Transformer;
    transformPlain?: StringTransformer;
}
declare const type$2 = "file-transform";

interface Config$2 extends ExecutorConfig$1 {
    targetDirectory?: executorArgument<string>;
    templatePath: executorArgument<string>;
    templateValues: executorArgument<{
        [key: string]: string;
    }>;
    destinationPathPrompt?: executorArgument<string>;
}
declare const type$1 = "new-file";

interface Config$1 extends ExecutorConfig$1 {
    message: executorArgument<string>;
}
declare const type = "print-message";

declare type ExecutorConfig = Config$4 | Config$3 | Config$2 | Config$1;

declare class RecipeExecutor<Options extends RecipeMeta> {
    private readonly steps;
    private readonly options;
    constructor(options: Options, steps: ExecutorConfig[]);
    run(cliArgs?: RecipeCLIArgs, cliFlags?: RecipeCLIFlags): Promise<void>;
}

declare type CliCommand = string | [string, ...string[]];
interface Config extends ExecutorConfig$1 {
    command: CliCommand;
}

interface IRecipeBuilder {
    setName(name: string): IRecipeBuilder;
    setDescription(description: string): IRecipeBuilder;
    printMessage(step: Omit<Omit<Config$1, "stepType">, "explanation">): IRecipeBuilder;
    setOwner(owner: string): IRecipeBuilder;
    setRepoLink(repoLink: string): IRecipeBuilder;
    addAddDependenciesStep(step: Omit<Config$4, "stepType">): IRecipeBuilder;
    addNewFilesStep(step: Omit<Config$2, "stepType">): IRecipeBuilder;
    addTransformFilesStep(step: Omit<Config$3, "stepType">): IRecipeBuilder;
    addRunCommandStep(step: Omit<Config, "stepType">): IRecipeBuilder;
    build(): RecipeExecutor<any>;
}
declare function RecipeBuilder(): IRecipeBuilder;

declare const paths: {
    document(): string;
    app(): string;
    blitzServer(): string | undefined;
    blitzClient(): string | undefined;
    entry(): string;
    nextConfig(): string;
    babelConfig(): string;
    packageJson(): string;
    prismaSchema(): string;
};

declare function addImport(program: Program, importToAdd: j__default.ImportDeclaration): Program;

declare const addBlitzMiddleware: (program: Program, middleware: ExpressionKind) => Program;

declare const findModuleExportsExpressions: (program: Program) => jscodeshift_src_Collection.Collection<ast_types.namedTypes.AssignmentExpression>;

/**
 * Adds an enum to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param enumProps - the enum to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaEnum(source, {
      type: "enum",
      name: "Role",
      enumerators: [
        {type: "enumerator", name: "USER"},
        {type: "enumerator", name: "ADMIN"},
      ],
    })
 * ```
 */
declare function addPrismaEnum(source: string, enumProps: Enum): Promise<string>;

/**
 * Adds a field to a model in your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param modelName - name of the model to add a field to
 * @param fieldProps - the field to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaField(source, "Project", {
      type: "field",
      name: "name",
      fieldType: "String",
      optional: false,
      attributes: [{type: "attribute", kind: "field", name: "unique"}],
    })
 * ```
 */
declare function addPrismaField(source: string, modelName: string, fieldProps: Field): Promise<string>;

/**
 * Adds a generator to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param generatorProps - the generator to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaGenerator(source, {
      type: "generator",
      name: "nexusPrisma",
      assignments: [{type: "assignment", key: "provider", value: '"nexus-prisma"'}],
    })
 * ```
 */
declare function addPrismaGenerator(source: string, generatorProps: Generator): Promise<string>;

/**
 * Adds a field to a model in your schema.prisma data model.
 *
 * @remarks Not ready for actual use
 * @param source - schema.prisma source file contents
 * @param modelName - name of the model to add a field to
 * @param attributeProps - the model attribute (such as an index) to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 * addPrismaModelAttribute(source, "Project", {
 *   type: "attribute",
 *   kind: "model",
 *   name: "index",
 *   args: [{ type: "attributeArgument", value: { type: "array", args: ["name"] } }]
 * });
 * ```
 */
declare function addPrismaModelAttribute(source: string, modelName: string, attributeProps: ModelAttribute): Promise<string>;

/**
 * Adds an enum to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param modelProps - the model to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaModel(source, {
      type: "model",
      name: "Project",
      properties: [{type: "field", name: "id", fieldType: "String"}],
    })
 * ```
 */
declare function addPrismaModel(source: string, modelProps: Model): Promise<string>;

/**
 * A file transformer that parses a schema.prisma string, offers you a callback
 * of the parsed document object, then takes your changes to the document and
 * writes out a new schema.prisma string with the changes applied.
 *
 * @param source - schema.prisma source file contents
 * @param producer - a callback function that can mutate the parsed data model
 * @returns The modified schema.prisma source
 */
declare function produceSchema(source: string, producer: (schema: Schema) => void): Promise<string>;

/**
 * Modify the prisma datasource metadata to use the provider and url specified.
 *
 * @param source - schema.prisma source file contents
 * @param datasourceProps - datasource object to assign to the schema
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  setPrismaDataSource(source, {
      type: "datasource",
      name: "db",
      assignments: [
        {type: "assignment", key: "provider", value: '"postgresql"'},
        {
          type: "assignment",
          key: "url",
          value: {type: "function", name: "env", params: ['"DATABASE_URL"']},
        },
      ],
    })
 * ```
 */
declare function setPrismaDataSource(source: string, datasourceProps: Datasource): Promise<string>;

declare function transformNextConfig(program: Program): {
    program: Program;
    configObj: [];
    pushToConfig: (property: j__default.ObjectProperty) => void;
    wrapConfig: (func: string | j__default.CallExpression) => {
        withBlitz: j__default.Identifier | j__default.CallExpression;
    };
    addRequireStatement: (identifier: string, packageName: string) => void;
};

declare function withComments<Node extends {
    comments?: CommentKind[] | null;
}>(node: Node, comments: CommentKind[]): Node;
declare function withTypeAnnotation<Node extends {
    typeAnnotation?: TypeAnnotationKind | TSTypeAnnotationKind | null;
}>(node: Node, type: Parameters<typeof j__default.tsTypeAnnotation>[0]): Node;

declare function wrapBlitzConfig(program: Program, functionName: string): Program;

declare type AddBabelItemDefinition = string | [name: string, options: JsonObject];
declare const addBabelPreset: (program: Program, preset: AddBabelItemDefinition) => Program;
declare const addBabelPlugin: (program: Program, plugin: AddBabelItemDefinition) => Program;

declare function wrapAppWithProvider(program: Program, element: string, attributes?: string[]): Program;

export { type$3 as AddDependencyType, ExecutorConfig$1 as ExecutorConfig, ExecutorConfig as ExecutorConfigUnion, type$2 as FileTransformType, Frontmatter, IExecutor, IRecipeBuilder, type$1 as NewFileType, type as PrintMessageType, Program, RecipeBuilder, RecipeCLIArgs, RecipeCLIFlags, RecipeExecutor, addBabelPlugin, addBabelPreset, addBlitzMiddleware, addImport, addPrismaEnum, addPrismaField, addPrismaGenerator, addPrismaModel, addPrismaModelAttribute, customTsParser, executorArgument, findModuleExportsExpressions, getExecutorArgument, paths, produceSchema, setPrismaDataSource, transformNextConfig, withComments, withTypeAnnotation, wrapAppWithProvider, wrapBlitzConfig };
