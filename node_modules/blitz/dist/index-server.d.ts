import { ComponentType } from 'react';
import * as http from 'http';
import { IncomingMessage, ServerResponse } from 'http';
import { UrlObject } from 'url';
import { ZodError } from 'zod';
import { ISettingsParam, TLogLevelName, Logger } from 'tslog';
import c from 'chalk';
import { Table } from 'console-table-printer';
import ora from 'ora';

declare global {
    var _blitz_prismaClient: any;
}

declare class AuthenticationError extends Error {
    name: string;
    statusCode: number;
    constructor(message?: string);
    get _clearStack(): boolean;
}
declare class CSRFTokenMismatchError extends Error {
    name: string;
    statusCode: number;
    get _clearStack(): boolean;
}
declare class AuthorizationError extends Error {
    name: string;
    statusCode: number;
    constructor(message?: string);
    get _clearStack(): boolean;
}
declare class NotFoundError extends Error {
    name: string;
    statusCode: number;
    constructor(message?: string);
    get _clearStack(): boolean;
}
declare class RedirectError extends Error {
    name: string;
    statusCode: number;
    url: UrlObject | string;
    constructor(url: UrlObject | string);
    get _clearStack(): boolean;
}
declare class PaginationArgumentError extends Error {
    name: string;
    statusCode: number;
    constructor(message?: string);
}

interface Ctx {
}
interface RouteUrlObject extends Pick<UrlObject, "pathname" | "query"> {
    pathname: string;
}
declare type ResolverConfig = {
    httpMethod: "GET" | "POST";
};
declare type BlitzCliConfig = {
    customTemplates?: string;
};
declare const isRouteUrlObject: (x: any) => x is RouteUrlObject;
declare type AsyncFunc = (...args: any) => Promise<any>;
/**
 * Infer the type of the parameter from function that takes a single argument
 */
declare type FirstParam<F extends (...args: any) => Promise<any>> = Parameters<F>[0];
/**
 * If type has a Promise, unwrap it. Otherwise return the original type
 */
declare type Await<T> = T extends PromiseLike<infer U> ? U : T;
/**
 * Ensure the type is a promise
 */
declare type EnsurePromise<T> = T extends PromiseLike<unknown> ? T : Promise<T>;
/**
 * Get the return type of a function which returns a Promise.
 */
declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = Await<ReturnType<T>>;
interface CancellablePromise<T> extends Promise<T> {
    cancel?: Function;
}
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare type Simplify<T> = {
    [P in keyof T]: T[P];
};
declare type AddParameters<TFunction extends (...args: any) => any, TParameters extends [...args: any]> = (...args: [...Parameters<TFunction>, ...TParameters]) => ReturnType<TFunction>;

declare const runPrisma: (args: string[], silent?: boolean) => Promise<{
    success: boolean;
    stderr: string | undefined;
} | {
    success: boolean;
    stderr?: undefined;
}>;

interface Constructor<T = unknown> {
    new (...args: never[]): T;
}
interface EnhancedPrismaClientAddedMethods {
    $reset: () => Promise<void>;
}
interface EnhancedPrismaClientConstructor<TPrismaClientCtor extends Constructor> {
    new (...args: ConstructorParameters<TPrismaClientCtor>): InstanceType<TPrismaClientCtor> & EnhancedPrismaClientAddedMethods;
}
declare const enhancePrisma: <TPrismaClientCtor extends Constructor<unknown>>(client: TPrismaClientCtor) => EnhancedPrismaClientConstructor<TPrismaClientCtor>;

declare function handleRequestWithMiddleware<Req extends IncomingMessage = IncomingMessage, Res extends ServerResponse = ServerResponse, MiddlewareResult = void | Promise<void>>(req: Req, res: Res, middleware: RequestMiddleware<Req, Res, MiddlewareResult>[], { throwOnError, stackPrintOnError, }?: {
    throwOnError?: boolean;
    stackPrintOnError?: boolean;
}): Promise<void>;
/**
 * If the middleware function doesn't declare receiving the `next` callback
 * assume that it's synchronous and invoke `next` ourselves
 */
declare function noCallbackHandler<Req extends IncomingMessage = IncomingMessage, Res = MiddlewareResponse>(req: Req, res: Res, next: MiddlewareNext, middleware: RequestMiddleware<Req, Res>): void | Promise<void>;
/**
 * The middleware function does include the `next` callback so only resolve
 * the Promise when it's called. If it's never called, the middleware stack
 * completion will stall
 */
declare function withCallbackHandler<Req extends IncomingMessage = IncomingMessage, Res = MiddlewareResponse>(req: Req, res: Res, next: MiddlewareNext, middleware: RequestMiddleware<Req, Res>): Promise<unknown>;
/**
 * Returns a Blitz middleware function that varies its async logic based on if the
 * given middleware function declares at least 3 parameters, i.e. includes
 * the `next` callback function
 */
declare function connectMiddleware<Req extends IncomingMessage = IncomingMessage, Res extends MiddlewareResponse = MiddlewareResponse>(middleware: RequestMiddleware<Req, Res>): RequestMiddleware<Req, Res>;
declare const secureProxyMiddleware: RequestMiddleware<IncomingMessage & {
    protocol?: string;
}, MiddlewareResponse>;

declare type PaginateArgs<QueryResult> = {
    skip?: number;
    take?: number;
    maxTake?: number;
    count: () => Promise<number>;
    query: (args: {
        skip: number;
        take: number;
    }) => Promise<QueryResult>;
};
declare function paginate<QueryResult>({ skip, take, maxTake, count: countQuery, query, }: PaginateArgs<QueryResult>): Promise<{
    items: Awaited<QueryResult>;
    nextPage: {
        take: number;
        skip: number;
    } | null;
    hasMore: boolean;
    pageCount: number;
    pageSize: number;
    from: number;
    to: number;
    count: number;
}>;

declare type BlitzLoggerSettings = ISettingsParam;
declare type BlitzLogLevel = TLogLevelName;
declare const baseLogger: (options?: BlitzLoggerSettings) => Logger;
declare const BlitzLogger: (settings?: BlitzLoggerSettings) => Logger;
declare const initializeLogger: (logger: Logger) => void;
declare const table: typeof Table;
declare const chalk: c.Chalk & c.ChalkFunction & {
    supportsColor: false | c.ColorSupport;
    Level: c.Level;
    Color: ("black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white" | "gray" | "grey" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright" | "blackBright") | ("bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright" | "bgGrey" | "bgBlackBright");
    ForegroundColor: "black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white" | "gray" | "grey" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright" | "blackBright";
    BackgroundColor: "bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright" | "bgGrey" | "bgBlackBright";
    Modifiers: "hidden" | "reset" | "bold" | "dim" | "italic" | "underline" | "inverse" | "strikethrough" | "visible";
    stderr: c.Chalk & {
        supportsColor: false | c.ColorSupport;
    };
};
declare const newLine: () => void;
declare const log: {
    withBrand: (str: string) => string;
    withCaret: (str: string) => string;
    branded: (msg: string) => void;
    clearLine: (msg?: string) => void;
    clearConsole: () => void;
    progress: (msg: string) => void;
    spinner: (str: string) => ora.Ora;
    success: (msg: string) => void;
    greenText: (str: string) => string;
    error: (msg: string) => void;
    variable: (val: any) => string;
    debug: any;
    Table: typeof Table;
};

declare function startWatcher(pagesDir?: string): Promise<void>;
declare function stopWatcher(): Promise<void>;

interface MiddlewareResponse<C extends Ctx = Ctx> extends ServerResponse {
    blitzCtx: C;
    blitzResult: unknown;
}
declare type MiddlewareNext = (error?: Error) => Promise<void> | void;
declare type RequestMiddleware<TRequest extends IncomingMessage = IncomingMessage, TResponse = ServerResponse, TResult = Promise<void> | void> = {
    (req: TRequest, res: TResponse, next: MiddlewareNext): TResult;
    type?: string;
    config?: Record<any, any>;
};
declare type BlitzServerPlugin<RequestMiddlewareType = RequestMiddleware<any, any>, TCtx extends Ctx = Ctx, TExports extends object = {}> = {
    requestMiddlewares: RequestMiddlewareType[];
    contextMiddleware?: (ctx: TCtx) => TCtx;
    exports?: TExports;
};
declare function createServerPlugin<TPluginOptions, TCtx extends Ctx, TPluginExports extends object, TMiddleware>(pluginConstructor: (options: TPluginOptions) => BlitzServerPlugin<TMiddleware, TCtx, TPluginExports>): (options: TPluginOptions) => BlitzServerPlugin<TMiddleware, TCtx, TPluginExports>;
declare function createSetupServer<TMiddleware extends RequestMiddleware, TExports extends object>(setupServerConstructor: (plugins: BlitzServerPlugin<TMiddleware>) => TExports): (plugins: BlitzServerPlugin<TMiddleware>) => TExports;
declare const BlitzServerMiddleware: <TMiddleware extends RequestMiddleware<any, any, void | Promise<void>> = RequestMiddleware<IncomingMessage, ServerResponse<IncomingMessage>, void | Promise<void>>>(middleware: TMiddleware) => BlitzServerPlugin;

declare function assert(condition: any, message: string): asserts condition;
declare const isServer: boolean;
declare const isClient: boolean;
declare const isPast: (date: Date) => boolean;
declare function differenceInMilliseconds(dateLeft: Date, dateRight: Date): number;
declare function differenceInMinutes(dateLeft: Date, dateRight: Date): number;
declare function addMilliseconds(date: Date, amount: number): Date;
declare function addMinutes(date: Date, amount: number): Date;
declare function addYears(date: Date, amount: number): Date;
declare function readCookie(name: string): any;
declare const setCookie: (name: string, value: string, expires: string) => void;
declare const deleteCookie: (name: string) => void;
declare function compose(middleware: RequestMiddleware<any, any, any>[]): RequestMiddleware<http.IncomingMessage, http.ServerResponse<http.IncomingMessage>, void | Promise<void>>;
/**
 * Formats milliseconds to a string
 * If more than 1s, it'll return seconds instead
 * @example
 * prettyMs(100) // -> `100ms`
 * prettyMs(1200) // -> `1.2s`
 * @param ms
 */
declare function prettyMs(ms: number): string;
declare function interopDefault(mod: any): any;
declare function truncateString(str: string, maxLength: number): string;

declare type ParserType = "sync" | "async";
declare function recursiveFormatZodErrors(errors: any): Record<string, any>;
declare function formatZodError(error: ZodError): Record<string, any>;
declare function validateZodSchema(schema: any, parserType: "sync"): (values: any) => any;
declare function validateZodSchema(schema: any, parserType: "async"): (values: any) => Promise<any>;
declare function validateZodSchema(schema: any): (values: any) => Promise<any>;

declare type BlitzProviderComponentType = <TProps = any>(component: ComponentType<TProps>) => {
    (props: TProps): JSX.Element;
    displayName: string;
};
interface ClientPlugin<Exports extends object> {
    events: {
        onSessionCreate?: () => void;
        onSessionDestroy?: () => void;
        onBeforeRender?: (props: React.ComponentProps<any>) => void;
    };
    middleware: {
        beforeHttpRequest?: (req: IncomingMessage, res: ServerResponse, next: (error?: Error) => Promise<void> | void) => void;
        beforeHttpResponse?: (req: IncomingMessage, res: ServerResponse, next: (error?: Error) => Promise<void> | void) => void;
    };
    exports: () => Exports;
    withProvider?: BlitzProviderComponentType;
}
declare function createClientPlugin<TPluginOptions, TPluginExports extends object>(pluginConstructor: (options: TPluginOptions) => ClientPlugin<TPluginExports>): (options: TPluginOptions) => ClientPlugin<TPluginExports>;

export { AddParameters, AsyncFunc, AuthenticationError, AuthorizationError, Await, BlitzCliConfig, BlitzLogLevel, BlitzLogger, BlitzLoggerSettings, BlitzProviderComponentType, BlitzServerMiddleware, BlitzServerPlugin, CSRFTokenMismatchError, CancellablePromise, ClientPlugin, Constructor, Ctx, EnhancedPrismaClientAddedMethods, EnhancedPrismaClientConstructor, EnsurePromise, FirstParam, MiddlewareNext, MiddlewareResponse, NotFoundError, PaginateArgs, PaginationArgumentError, ParserType, PromiseReturnType, RedirectError, RequestMiddleware, ResolverConfig, RouteUrlObject, Simplify, UnionToIntersection, addMilliseconds, addMinutes, addYears, assert, baseLogger, chalk, compose, connectMiddleware, createClientPlugin, createServerPlugin, createSetupServer, deleteCookie, differenceInMilliseconds, differenceInMinutes, enhancePrisma, formatZodError, handleRequestWithMiddleware, initializeLogger, interopDefault, isClient, isPast, isRouteUrlObject, isServer, log, newLine, noCallbackHandler, paginate, prettyMs, readCookie, recursiveFormatZodErrors, runPrisma, secureProxyMiddleware, setCookie, startWatcher, stopWatcher, table, truncateString, validateZodSchema, withCallbackHandler };
