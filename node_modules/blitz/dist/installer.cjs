'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const ink = require('ink');
const logging = require('./chunks/logging.cjs');
const React = require('react');
require('./index-browser.cjs');
require('p-event');
const spawn = require('cross-spawn');
require('resolve-from');
require('npm-which');
require('./chunks/routes-manifest.cjs');
const fs = require('fs-extra');
const Spinner = require('ink-spinner');
const path = require('path');
const diff = require('diff');
const j = require('jscodeshift');
const getBabelOptions = require('recast/parsers/_babel_options');
const babel = require('recast/parsers/babel');
const prompts = require('prompts');
const generator = require('@blitzjs/generator');
const index = require('./chunks/index.cjs');
const prismaAst = require('@mrleebo/prisma-ast');
require('tslog');
require('chalk');
require('console-table-printer');
require('ora');
require('readline');
require('superjson');
require('os');
require('fs');
require('find-up');
require('watchpack');
require('./chunks/helpers.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const React__namespace = /*#__PURE__*/_interopNamespace(React);
const React__default = /*#__PURE__*/_interopDefaultLegacy(React);
const fs__namespace = /*#__PURE__*/_interopNamespace(fs);
const Spinner__default = /*#__PURE__*/_interopDefaultLegacy(Spinner);
const path__namespace = /*#__PURE__*/_interopNamespace(path);
const j__default = /*#__PURE__*/_interopDefaultLegacy(j);
const getBabelOptions__default = /*#__PURE__*/_interopDefaultLegacy(getBabelOptions);
const babel__namespace = /*#__PURE__*/_interopNamespace(babel);
const prompts__default = /*#__PURE__*/_interopDefaultLegacy(prompts);

const Newline = ({ count = 1 }) => {
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    paddingBottom: count
  });
};

const EnterToContinue = ({
  message = "Press ENTER to continue"
}) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Newline, null), /* @__PURE__ */ React__namespace.createElement(ink.Text, {
  bold: true
}, message));

function useEnterToContinue(cb, additionalCondition = true) {
  ink.useInput((_input, key) => {
    if (additionalCondition && key.return) {
      cb();
    }
  });
}

function useUserInput(cliFlags) {
  const { isRawModeSupported } = ink.useStdin();
  return isRawModeSupported && !cliFlags.yesToAll;
}

function isDynamicExecutorArgument(input) {
  return typeof input === "function";
}
function Frontmatter({ executor }) {
  const lineLength = executor.stepName.length + 6;
  const verticalBorder = `+${new Array(lineLength).fill("\u2013").join("")}+`;
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column",
    paddingBottom: 1
  }, /* @__PURE__ */ React__namespace.createElement(Newline, null), /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(ink.Text, {
    color: "#8a3df0",
    bold: true
  }, verticalBorder), /* @__PURE__ */ React__namespace.createElement(ink.Text, {
    color: "#8a3df0",
    bold: true
  }, "\u23AA\xA0\xA0\xA0", executor.stepName, "\xA0\xA0\xA0\u23AA"), /* @__PURE__ */ React__namespace.createElement(ink.Text, {
    color: "#8a3df0",
    bold: true
  }, verticalBorder)), /* @__PURE__ */ React__namespace.createElement(ink.Text, {
    color: "gray",
    italic: true
  }, executor.explanation));
}
function getExecutorArgument(input, cliArgs) {
  if (isDynamicExecutorArgument(input)) {
    return input(cliArgs);
  }
  return input;
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __async$7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isAddDependencyExecutor(executor) {
  return executor.packages !== void 0;
}
const type$4 = "add-dependency";
function Package({ pkg, loading }) {
  return /* @__PURE__ */ React__namespace.createElement(ink.Text, null, `   `, loading ? /* @__PURE__ */ React__namespace.createElement(Spinner__default, null) : "\u{1F4E6}", ` ${pkg.name}@${pkg.version}`);
}
const DependencyList = ({
  lede = "Hang tight! Installing dependencies...",
  depsLoading = false,
  devDepsLoading = false,
  packages
}) => {
  const prodPackages = packages.filter((p) => !p.isDevDep);
  const devPackages = packages.filter((p) => p.isDevDep);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, lede), /* @__PURE__ */ React__namespace.createElement(Newline, null), prodPackages.length ? /* @__PURE__ */ React__namespace.createElement(ink.Text, null, "Dependencies to be installed:") : null, prodPackages.map((pkg) => /* @__PURE__ */ React__namespace.createElement(Package, {
    key: pkg.name,
    pkg,
    loading: depsLoading
  })), /* @__PURE__ */ React__namespace.createElement(Newline, null), devPackages.length ? /* @__PURE__ */ React__namespace.createElement(ink.Text, null, "Dev Dependencies to be installed:") : null, devPackages.map((pkg) => /* @__PURE__ */ React__namespace.createElement(Package, {
    key: pkg.name,
    pkg,
    loading: devDepsLoading
  })));
};
function getPackageManager() {
  if (fs__namespace.existsSync(path__namespace.resolve("yarn.lock"))) {
    return "yarn";
  } else if (fs__namespace.existsSync(path__namespace.resolve("pnpm-lock.yaml"))) {
    return "pnpm";
  } else {
    return "npm";
  }
}
function installPackages(packages, isDev = false) {
  return __async$7(this, null, function* () {
    const packageManager = getPackageManager();
    const isNPM = packageManager === "npm";
    const pkgInstallArg = isNPM ? "install" : "add";
    const args = [pkgInstallArg];
    if (isDev) {
      args.push(isNPM ? "--save-dev" : "-D");
    }
    packages.forEach((pkg) => {
      pkg.version ? args.push(`${pkg.name}@${pkg.version}`) : args.push(pkg.name);
    });
    yield new Promise((resolve) => {
      const cp = spawn.spawn(packageManager, args, {
        stdio: ["inherit", "pipe", "pipe"]
      });
      cp.on("exit", resolve);
    });
  });
}
const Commit$4 = ({ cliArgs, cliFlags, step, onChangeCommitted }) => {
  const userInput = useUserInput(cliFlags);
  const [depsInstalled, setDepsInstalled] = React__namespace.useState(false);
  const [devDepsInstalled, setDevDepsInstalled] = React__namespace.useState(false);
  const handleChangeCommitted = React__namespace.useCallback(() => {
    const packages = step.packages;
    const dependencies = packages.length === 1 ? "dependency" : "dependencies";
    onChangeCommitted(`Installed ${packages.length} ${dependencies}`);
  }, [onChangeCommitted, step]);
  React__namespace.useEffect(() => {
    function installDeps() {
      return __async$7(this, null, function* () {
        const packagesToInstall = getExecutorArgument(step.packages, cliArgs).filter(
          (p) => !p.isDevDep
        );
        yield installPackages(packagesToInstall);
        setDepsInstalled(true);
      });
    }
    installDeps();
  }, [cliArgs, step]);
  React__namespace.useEffect(() => {
    if (!depsInstalled)
      return;
    function installDevDeps() {
      return __async$7(this, null, function* () {
        const packagesToInstall = getExecutorArgument(step.packages, cliArgs).filter(
          (p) => p.isDevDep
        );
        yield installPackages(packagesToInstall, true);
        setDevDepsInstalled(true);
      });
    }
    installDevDeps();
  }, [cliArgs, depsInstalled, step]);
  React__namespace.useEffect(() => {
    if (depsInstalled && devDepsInstalled) {
      handleChangeCommitted();
    }
  }, [depsInstalled, devDepsInstalled, handleChangeCommitted]);
  if (!isAddDependencyExecutor(step)) {
    onChangeCommitted();
    return null;
  }
  const childProps = {
    depsInstalled,
    devDepsInstalled,
    handleChangeCommitted,
    step,
    cliArgs
  };
  if (userInput)
    return /* @__PURE__ */ React__namespace.createElement(CommitWithInput$3, __spreadValues$6({}, childProps));
  else
    return /* @__PURE__ */ React__namespace.createElement(CommitWithoutInput$3, __spreadValues$6({}, childProps));
};
const CommitWithInput$3 = ({
  depsInstalled,
  devDepsInstalled,
  handleChangeCommitted,
  step,
  cliArgs
}) => {
  useEnterToContinue(handleChangeCommitted, depsInstalled && devDepsInstalled);
  return /* @__PURE__ */ React__namespace.createElement(DependencyList, {
    depsLoading: !depsInstalled,
    devDepsLoading: !devDepsInstalled,
    packages: getExecutorArgument(step.packages, cliArgs)
  });
};
const CommitWithoutInput$3 = ({ depsInstalled, devDepsInstalled, step, cliArgs }) => /* @__PURE__ */ React__namespace.createElement(DependencyList, {
  depsLoading: !depsInstalled,
  devDepsLoading: !devDepsInstalled,
  packages: getExecutorArgument(step.packages, cliArgs)
});

const AddDependencyExecutor = {
  __proto__: null,
  isAddDependencyExecutor: isAddDependencyExecutor,
  type: type$4,
  getPackageManager: getPackageManager,
  installPackages: installPackages,
  Commit: Commit$4
};

var __async$6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const customTsParser = {
  parse(source, options) {
    const babelOptions = getBabelOptions__default(options);
    babelOptions.plugins.push("typescript");
    babelOptions.plugins.push("jsx");
    return babel__namespace.parser.parse(source, babelOptions);
  }
};
var TransformStatus = /* @__PURE__ */ ((TransformStatus2) => {
  TransformStatus2["Success"] = "success";
  TransformStatus2["Failure"] = "failure";
  return TransformStatus2;
})(TransformStatus || {});
function stringProcessFile(original, transformerFn) {
  return transformerFn(original);
}
function processFile(original, transformerFn) {
  return __async$6(this, null, function* () {
    const program = j__default(original, { parser: customTsParser });
    return (yield transformerFn(program)).toSource();
  });
}
function transform(processFile2, targetFilePaths) {
  return __async$6(this, null, function* () {
    const results = [];
    for (const filePath of targetFilePaths) {
      if (!fs__namespace.existsSync(filePath)) {
        results.push({
          status: "failure" /* Failure */,
          filename: filePath,
          error: new Error(`Error: ${filePath} not found`)
        });
      }
      try {
        const fileBuffer = fs__namespace.readFileSync(filePath);
        const fileSource = fileBuffer.toString("utf-8");
        const transformedCode = yield processFile2(fileSource);
        fs__namespace.writeFileSync(filePath, transformedCode);
        results.push({
          status: "success" /* Success */,
          filename: filePath
        });
      } catch (err) {
        results.push({
          status: "failure" /* Failure */,
          filename: filePath,
          error: err
        });
      }
    }
    return results;
  });
}

var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function getMatchingFiles(filter = "") {
  return __async$5(this, null, function* () {
    let { globby } = yield import('globby');
    return globby(filter, { expandDirectories: true });
  });
}
function filePrompt(options) {
  return __async$5(this, null, function* () {
    const choices = options.getChoices ? options.getChoices(options.context) : yield getMatchingFiles(options.globFilter);
    if (choices.length === 1) {
      return `${choices[0]}`;
    }
    const results = yield prompts__default({
      type: "autocomplete",
      name: "file",
      message: "Select the target file",
      limit: 10,
      choices: choices.map((choice) => {
        return { title: choice, value: choice };
      })
    });
    return results.file;
  });
}

var __defProp$5 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isFileTransformExecutor(executor) {
  return executor.transform !== void 0 || executor.transformPlain !== void 0;
}
const type$3 = "file-transform";
const Propose = ({ cliArgs, cliFlags, onProposalAccepted, step }) => {
  const userInput = useUserInput(cliFlags);
  const [diff$1, setDiff] = React__namespace.useState(null);
  const [error, setError] = React__namespace.useState(null);
  const [filePath, setFilePath] = React__namespace.useState("");
  const [proposalAccepted, setProposalAccepted] = React__namespace.useState(false);
  const acceptProposal = React__namespace.useCallback(() => {
    setProposalAccepted(true);
    onProposalAccepted(filePath);
  }, [onProposalAccepted, filePath]);
  React__namespace.useEffect(() => {
    function generateDiff() {
      return __async$4(this, null, function* () {
        const fileToTransform = yield filePrompt({
          context: cliArgs,
          globFilter: getExecutorArgument(step.singleFileSearch, cliArgs),
          getChoices: step.selectTargetFiles
        });
        setFilePath(fileToTransform);
        const originalFile = fs__namespace.readFileSync(fileToTransform).toString("utf-8");
        const newFile = yield step.transformPlain ? stringProcessFile(originalFile, step.transformPlain) : processFile(originalFile, step.transform);
        return diff.createPatch(fileToTransform, originalFile, newFile);
      });
    }
    generateDiff().then(setDiff, setError);
  }, [cliArgs, step]);
  if (error)
    throw error;
  if (!diff$1) {
    return /* @__PURE__ */ React__namespace.createElement(ink.Box, null, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, /* @__PURE__ */ React__namespace.createElement(Spinner__default, null), "Generating file diff..."));
  }
  const childProps = {
    diff: diff$1,
    filePath,
    proposalAccepted,
    acceptProposal
  };
  if (userInput)
    return /* @__PURE__ */ React__namespace.createElement(ProposeWithInput, __spreadValues$5({}, childProps));
  else
    return /* @__PURE__ */ React__namespace.createElement(ProposeWithoutInput, __spreadValues$5({}, childProps));
};
const Diff = ({ diff }) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, diff.split("\n").slice(2).map((line, idx) => {
  let styleProps = {};
  if (line.startsWith("-") && !line.startsWith("---")) {
    styleProps.bold = true;
    styleProps.color = "red";
  } else if (line.startsWith("+") && !line.startsWith("+++")) {
    styleProps.bold = true;
    styleProps.color = "green";
  }
  return /* @__PURE__ */ React__namespace.createElement(ink.Text, __spreadProps(__spreadValues$5({}, styleProps), {
    key: idx
  }), line);
}));
const ProposeWithInput = ({
  diff,
  filePath,
  proposalAccepted,
  acceptProposal
}) => {
  useEnterToContinue(acceptProposal, filePath !== "" && !proposalAccepted);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(Diff, {
    diff
  }), /* @__PURE__ */ React__namespace.createElement(EnterToContinue, {
    message: "The above changes will be made. Press ENTER to continue"
  }));
};
const ProposeWithoutInput = ({
  diff,
  filePath,
  proposalAccepted,
  acceptProposal
}) => {
  React__namespace.useEffect(() => {
    if (filePath !== "" && !proposalAccepted) {
      acceptProposal();
    }
  }, [acceptProposal, filePath, proposalAccepted]);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(Diff, {
    diff
  }));
};
const Commit$3 = ({ onChangeCommitted, proposalData: filePath, step }) => {
  React__namespace.useEffect(() => {
    void function() {
      return __async$4(this, null, function* () {
        const results = yield transform(
          (original) => __async$4(this, null, function* () {
            return yield step.transformPlain ? stringProcessFile(original, step.transformPlain) : processFile(original, step.transform);
          }),
          [filePath]
        );
        if (results.some((r) => r.status === TransformStatus.Failure)) {
          console.error(results);
        }
        onChangeCommitted(`Modified file: ${filePath}`);
      });
    }();
  }, [filePath, onChangeCommitted, step]);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, null, /* @__PURE__ */ React__namespace.createElement(Spinner__default, null), /* @__PURE__ */ React__namespace.createElement(ink.Text, null, "Applying file changes"));
};

const FileTransformExecutor = {
  __proto__: null,
  isFileTransformExecutor: isFileTransformExecutor,
  type: type$3,
  Propose: Propose,
  Commit: Commit$3
};

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isNewFileExecutor(executor) {
  return executor.templatePath !== void 0;
}
const type$2 = "new-file";
class TempGenerator extends generator.Generator {
  constructor(options) {
    super(options);
    this.returnResults = true;
    this.sourceRoot = { type: "absolute", path: options.templateRoot };
    this.templateValues = options.templateValues;
    this.targetDirectory = options.targetDirectory || ".";
  }
  getTemplateValues() {
    return this.templateValues;
  }
  getTargetDirectory() {
    return this.targetDirectory;
  }
}
const Commit$2 = ({ cliArgs, cliFlags, onChangeCommitted, step }) => {
  const userInput = useUserInput(cliFlags);
  const generatorArgs = React__namespace.useMemo(
    () => ({
      destinationRoot: ".",
      targetDirectory: getExecutorArgument(step.targetDirectory, cliArgs),
      templateRoot: getExecutorArgument(step.templatePath, cliArgs),
      templateValues: getExecutorArgument(step.templateValues, cliArgs)
    }),
    [cliArgs, step]
  );
  const [fileCreateOutput, setFileCreateOutput] = React.useState("");
  const [changeCommited, setChangeCommited] = React.useState(false);
  const fileCreateLines = fileCreateOutput.split("\n");
  const handleChangeCommitted = React__namespace.useCallback(() => {
    setChangeCommited(true);
    onChangeCommitted(
      `Successfully created ${fileCreateLines.map((l) => l.split(" ").slice(1).join("").trim()).join(", ")}`
    );
  }, [fileCreateLines, onChangeCommitted]);
  React.useEffect(() => {
    function createNewFiles() {
      return __async$3(this, null, function* () {
        if (!fileCreateOutput) {
          const generator = new TempGenerator(generatorArgs);
          const results = yield generator.run();
          setFileCreateOutput(results);
        }
      });
    }
    createNewFiles();
  }, [fileCreateOutput, generatorArgs]);
  const childProps = {
    changeCommited,
    fileCreateOutput,
    handleChangeCommitted
  };
  if (userInput)
    return /* @__PURE__ */ React__namespace.createElement(CommitWithInput$2, __spreadValues$4({}, childProps));
  else
    return /* @__PURE__ */ React__namespace.createElement(CommitWithoutInput$2, __spreadValues$4({}, childProps));
};
const CommitWithInput$2 = ({
  changeCommited,
  fileCreateOutput,
  handleChangeCommitted
}) => {
  useEnterToContinue(handleChangeCommitted, !changeCommited && fileCreateOutput !== "");
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, fileCreateOutput !== "" && /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, fileCreateOutput), /* @__PURE__ */ React__namespace.createElement(EnterToContinue, null)));
};
const CommitWithoutInput$2 = ({
  changeCommited,
  fileCreateOutput,
  handleChangeCommitted
}) => {
  React__namespace.useEffect(() => {
    if (!changeCommited && fileCreateOutput !== "") {
      handleChangeCommitted();
    }
  }, [changeCommited, fileCreateOutput, handleChangeCommitted]);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, fileCreateOutput !== "" && /* @__PURE__ */ React__namespace.createElement(ink.Text, null, fileCreateOutput));
};

const NewFileExecutor = {
  __proto__: null,
  isNewFileExecutor: isNewFileExecutor,
  type: type$2,
  Commit: Commit$2
};

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const type$1 = "print-message";
const Commit$1 = ({ cliArgs, cliFlags, onChangeCommitted, step }) => {
  const userInput = useUserInput(cliFlags);
  const generatorArgs = React__namespace.useMemo(
    () => ({
      message: getExecutorArgument(step.message, cliArgs),
      stepName: getExecutorArgument(step.stepName, cliArgs)
    }),
    [cliArgs, step]
  );
  const [changeCommited, setChangeCommited] = React__namespace.useState(false);
  const handleChangeCommitted = React__namespace.useCallback(() => {
    setChangeCommited(true);
    onChangeCommitted(generatorArgs.stepName);
  }, [onChangeCommitted, generatorArgs]);
  const childProps = {
    changeCommited,
    generatorArgs,
    handleChangeCommitted
  };
  if (userInput)
    return /* @__PURE__ */ React__namespace.createElement(CommitWithInput$1, __spreadValues$3({}, childProps));
  else
    return /* @__PURE__ */ React__namespace.createElement(CommitWithoutInput$1, __spreadValues$3({}, childProps));
};
const CommitWithInput$1 = ({
  changeCommited,
  generatorArgs,
  handleChangeCommitted
}) => {
  useEnterToContinue(handleChangeCommitted, !changeCommited);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, generatorArgs.message), /* @__PURE__ */ React__namespace.createElement(EnterToContinue, null));
};
const CommitWithoutInput$1 = ({
  changeCommited,
  generatorArgs,
  handleChangeCommitted
}) => {
  React__namespace.useEffect(() => {
    if (!changeCommited) {
      handleChangeCommitted();
    }
  }, [changeCommited, handleChangeCommitted]);
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, generatorArgs.message));
};

const PrintMessageExecutor = {
  __proto__: null,
  type: type$1,
  Commit: Commit$1
};

var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const type = "run-command";
function Command({ command, loading }) {
  return /* @__PURE__ */ React__namespace.createElement(ink.Text, null, `   `, loading ? /* @__PURE__ */ React__namespace.createElement(Spinner__default, null) : "\u2705", ` ${typeof command === "string" ? command : command.join(" ")}`);
}
const CommandList = ({
  lede = "Hang tight! Running...",
  commandLoading = false,
  step,
  command
}) => {
  return /* @__PURE__ */ React__namespace.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__namespace.createElement(ink.Text, null, lede), /* @__PURE__ */ React__namespace.createElement(Newline, null), /* @__PURE__ */ React__namespace.createElement(Command, {
    key: step.stepId,
    command,
    loading: commandLoading
  }));
};
function executeCommand(input) {
  return __async$2(this, null, function* () {
    const argsRegex = /("[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|\/[^/\\]*(?:\\[\S\s][^/\\]*)*\/[gimy]*(?=\s|$)|(?:\\\s|\S)+)/g;
    const command = Array.isArray(input) ? input : input.match(argsRegex) || [];
    if (command.length === 0) {
      throw new Error(`The command is too short: \`${JSON.stringify(input)}\``);
    }
    yield new Promise((resolve) => {
      const cp = spawn.spawn(`${command[0]}`, command.slice(1), {
        stdio: ["inherit", "pipe", "pipe"]
      });
      cp.on("exit", resolve);
      cp.stdout.on("data", () => {
      });
    });
  });
}
const Commit = ({ cliArgs, cliFlags, step, onChangeCommitted }) => {
  const userInput = useUserInput(cliFlags);
  const [commandInstalled, setCommandInstalled] = React__namespace.useState(false);
  const executorCommand = getExecutorArgument(step.command, cliArgs);
  const handleChangeCommitted = React__namespace.useCallback(() => {
    onChangeCommitted(`Executed command ${executorCommand}`);
  }, [executorCommand, onChangeCommitted]);
  React__namespace.useEffect(() => {
    function runCommand() {
      return __async$2(this, null, function* () {
        yield executeCommand(executorCommand);
        setCommandInstalled(true);
      });
    }
    runCommand();
  }, [cliArgs, step, executorCommand]);
  React__namespace.useEffect(() => {
    if (commandInstalled) {
      handleChangeCommitted();
    }
  }, [commandInstalled, handleChangeCommitted]);
  const childProps = {
    commandInstalled,
    handleChangeCommitted,
    command: executorCommand,
    cliArgs,
    step
  };
  if (userInput)
    return /* @__PURE__ */ React__namespace.createElement(CommitWithInput, __spreadValues$2({}, childProps));
  else
    return /* @__PURE__ */ React__namespace.createElement(CommitWithoutInput, __spreadValues$2({}, childProps));
};
const CommitWithInput = ({
  commandInstalled,
  handleChangeCommitted,
  command,
  step
}) => {
  useEnterToContinue(handleChangeCommitted, commandInstalled);
  return /* @__PURE__ */ React__namespace.createElement(CommandList, {
    commandLoading: !commandInstalled,
    step,
    command
  });
};
const CommitWithoutInput = ({ commandInstalled, command, step }) => /* @__PURE__ */ React__namespace.createElement(CommandList, {
  commandLoading: !commandInstalled,
  step,
  command
});

const RunCommandExecutor = {
  __proto__: null,
  type: type,
  executeCommand: executeCommand,
  Commit: Commit
};

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
const ExecutorMap = {
  [type$4]: AddDependencyExecutor,
  [type$2]: NewFileExecutor,
  [type$1]: PrintMessageExecutor,
  [type$3]: FileTransformExecutor,
  [type]: RunCommandExecutor
};
function recipeReducer(state, action) {
  const newState = __spreadValues$1({}, state);
  const step = newState.steps[newState.current];
  switch (action.type) {
    case 1 /* ProposeChange */:
      index.assert(step, "Step is empty in recipeReducer function");
      step.status = 1 /* Proposed */;
      break;
    case 3 /* CommitApproved */:
      index.assert(step, "Step is empty in recipeReducer function");
      step.status = 2 /* ReadyToCommit */;
      step.proposalData = action.data;
      break;
    case 2 /* ApplyChange */:
      index.assert(step, "Step is empty in recipeReducer function");
      step.status = 3 /* Committing */;
      break;
    case 4 /* CompleteChange */:
      index.assert(step, "Step is empty in recipeReducer function");
      step.status = 4 /* Committed */;
      step.successMsg = action.data;
      newState.current = Math.min(newState.current + 1, newState.steps.length - 1);
      break;
    case 0 /* SkipStep */:
      newState.current += 1;
      break;
  }
  return newState;
}
const DispatchContext = React__default.createContext(() => {
});
function WelcomeMessage({
  recipeMeta,
  enterToContinue = true
}) {
  return /* @__PURE__ */ React__default.createElement(ink.Box, {
    flexDirection: "column"
  }, /* @__PURE__ */ React__default.createElement(ink.Text, {
    color: "#8a3df0",
    bold: true
  }, "Recipe: ", recipeMeta.name), /* @__PURE__ */ React__default.createElement(Newline, null), /* @__PURE__ */ React__default.createElement(ink.Text, {
    color: "gray"
  }, /* @__PURE__ */ React__default.createElement(ink.Text, {
    italic: true
  }, recipeMeta.description)), /* @__PURE__ */ React__default.createElement(Newline, null), /* @__PURE__ */ React__default.createElement(ink.Text, {
    color: "gray"
  }, "Repo: ", /* @__PURE__ */ React__default.createElement(ink.Text, {
    italic: true
  }, recipeMeta.repoLink)), /* @__PURE__ */ React__default.createElement(ink.Text, {
    color: "gray"
  }, "Author: ", /* @__PURE__ */ React__default.createElement(ink.Text, {
    italic: true
  }, recipeMeta.owner)), enterToContinue && /* @__PURE__ */ React__default.createElement(EnterToContinue, null));
}
function StepMessages({ state }) {
  const messages = state.steps.map((step) => {
    var _a;
    return {
      msg: step.successMsg,
      icon: (_a = step.executor.successIcon) != null ? _a : "\u2705"
    };
  }).filter((s) => s.msg);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, messages.map(({ msg, icon }, index) => /* @__PURE__ */ React__default.createElement(ink.Text, {
    key: msg + index,
    color: "green"
  }, msg === "\n" ? "" : icon, " ", msg)));
}
function StepExecutor({
  cliArgs,
  cliFlags,
  proposalData,
  step,
  status
}) {
  const executor = ExecutorMap[step.stepType];
  index.assert(executor, `Executor not found for ${step.stepType}`);
  const { Propose, Commit } = executor;
  const dispatch = React__default.useContext(DispatchContext);
  const handleProposalAccepted = React__default.useCallback(
    (msg) => {
      dispatch({ type: 3 /* CommitApproved */, data: msg });
    },
    [dispatch]
  );
  const handleChangeCommitted = React__default.useCallback(
    (msg) => {
      dispatch({ type: 4 /* CompleteChange */, data: msg });
    },
    [dispatch]
  );
  React__default.useEffect(() => {
    if (status === 0 /* Pending */) {
      dispatch({ type: 1 /* ProposeChange */ });
    } else if (status === 2 /* ReadyToCommit */) {
      dispatch({ type: 2 /* ApplyChange */ });
    }
    if (status === 1 /* Proposed */ && !Propose) {
      dispatch({ type: 3 /* CommitApproved */ });
    }
  }, [dispatch, status, Propose]);
  return /* @__PURE__ */ React__default.createElement(ink.Box, {
    flexDirection: "column"
  }, status !== 4 /* Committed */ ? /* @__PURE__ */ React__default.createElement(Frontmatter, {
    executor: step
  }) : null, [1 /* Proposed */].includes(status) && Propose ? /* @__PURE__ */ React__default.createElement(Propose, {
    cliArgs,
    cliFlags,
    step,
    onProposalAccepted: handleProposalAccepted
  }) : null, [3 /* Committing */].includes(status) ? /* @__PURE__ */ React__default.createElement(Commit, {
    cliArgs,
    cliFlags,
    proposalData,
    step,
    onChangeCommitted: handleChangeCommitted
  }) : null);
}
function RecipeRenderer({ cliArgs, cliFlags, steps, recipeMeta }) {
  const userInput = useUserInput(cliFlags);
  const { exit } = ink.useApp();
  const mappedSteps = steps.map((e) => ({
    executor: e,
    status: 0 /* Pending */,
    successMsg: ""
  }));
  if (steps.length === 0) {
    exit(new Error("This recipe has no steps"));
  }
  const [state, dispatch] = React__default.useReducer(recipeReducer, {
    current: userInput ? -1 : 0,
    steps: mappedSteps
  });
  React__default.useEffect(() => {
    var _a;
    if (state.current === state.steps.length - 1 && ((_a = state.steps[state.current]) == null ? void 0 : _a.status) === 4 /* Committed */) {
      exit();
    }
  });
  return /* @__PURE__ */ React__default.createElement(DispatchContext.Provider, {
    value: dispatch
  }, userInput ? /* @__PURE__ */ React__default.createElement(RecipeRendererWithInput, {
    cliArgs,
    cliFlags,
    state,
    recipeMeta
  }) : /* @__PURE__ */ React__default.createElement(RecipeRendererWithoutInput, {
    cliArgs,
    cliFlags,
    state,
    recipeMeta
  }));
}
function RecipeRendererWithInput({
  cliArgs,
  cliFlags,
  recipeMeta,
  state
}) {
  var _a;
  const { exit } = ink.useApp();
  const dispatch = React__default.useContext(DispatchContext);
  const step = state.steps[state.current];
  ink.useInput((input, key) => {
    if (input === "c" && key.ctrl) {
      exit(new Error("You aborted installation"));
      return;
    }
  });
  useEnterToContinue(() => dispatch({ type: 0 /* SkipStep */ }), state.current === -1);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(StepMessages, {
    state
  }), state.current === -1 ? /* @__PURE__ */ React__default.createElement(WelcomeMessage, {
    recipeMeta
  }) : step ? /* @__PURE__ */ React__default.createElement(StepExecutor, {
    cliArgs,
    cliFlags,
    proposalData: (_a = state.steps[state.current]) == null ? void 0 : _a.proposalData,
    step: step.executor,
    status: step.status
  }) : new Error("Step not found in RecipeRendererWithInput"));
}
function RecipeRendererWithoutInput({
  cliArgs,
  cliFlags,
  recipeMeta,
  state
}) {
  var _a, _b, _c;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(WelcomeMessage, {
    recipeMeta,
    enterToContinue: false
  }), /* @__PURE__ */ React__default.createElement(StepMessages, {
    state
  }), /* @__PURE__ */ React__default.createElement(StepExecutor, {
    cliArgs,
    cliFlags,
    proposalData: (_a = state.steps[state.current]) == null ? void 0 : _a.proposalData,
    step: (_b = state.steps[state.current]) == null ? void 0 : _b.executor,
    status: (_c = state.steps[state.current]) == null ? void 0 : _c.status
  }));
}

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class RecipeExecutor {
  constructor(options, steps) {
    this.options = options;
    this.steps = steps;
  }
  run() {
    return __async$1(this, arguments, function* (cliArgs = {}, cliFlags = { yesToAll: false }) {
      try {
        const { waitUntilExit } = ink.render(
          /* @__PURE__ */ React__default.createElement(RecipeRenderer, {
            cliArgs,
            cliFlags,
            steps: this.steps,
            recipeMeta: this.options
          }),
          { exitOnCtrlC: false }
        );
        yield waitUntilExit();
        logging.baseLogger({ displayDateTime: false, displayLogLevel: false }).info(
          `
\u{1F389} The ${this.options.name} recipe has been installed!
`
        );
      } catch (e) {
        logging.baseLogger({ displayDateTime: false }).error(e);
        return;
      }
    });
  }
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function RecipeBuilder() {
  const steps = [];
  const meta = {};
  return {
    setName(name) {
      meta.name = name;
      return this;
    },
    setDescription(description) {
      meta.description = description;
      return this;
    },
    printMessage(step) {
      steps.push(__spreadValues({
        stepType: type$1
      }, step));
      return this;
    },
    setOwner(owner) {
      meta.owner = owner;
      return this;
    },
    setRepoLink(repoLink) {
      meta.repoLink = repoLink;
      return this;
    },
    addAddDependenciesStep(step) {
      steps.push(__spreadValues({
        stepType: type$4
      }, step));
      return this;
    },
    addNewFilesStep(step) {
      steps.push(__spreadValues({
        stepType: type$2
      }, step));
      return this;
    },
    addTransformFilesStep(step) {
      steps.push(__spreadValues({
        stepType: type$3
      }, step));
      return this;
    },
    addRunCommandStep(step) {
      steps.push(__spreadValues({
        stepType: type
      }, step));
      return this;
    },
    build() {
      return new RecipeExecutor(meta, steps);
    }
  };
}

function ext(jsx = false) {
  return fs__namespace.existsSync(path__namespace.resolve("tsconfig.json")) ? jsx ? ".tsx" : ".ts" : ".js";
}
function getBlitzPath(type) {
  const appPath = `app/blitz-${type}${ext(false)}`;
  const srcPath = `src/blitz-${type}${ext(false)}`;
  const appDir = fs__namespace.existsSync(path__namespace.resolve(appPath));
  const srcDir = fs__namespace.existsSync(path__namespace.resolve(srcPath));
  if (appDir) {
    return appPath;
  } else if (srcDir) {
    return srcPath;
  }
}
const paths = {
  document() {
    return `pages/_document${ext(true)}`;
  },
  app() {
    return `pages/_app${ext(true)}`;
  },
  blitzServer() {
    return getBlitzPath("server");
  },
  blitzClient() {
    return getBlitzPath("client");
  },
  entry() {
    return `pages/index${ext(true)}`;
  },
  nextConfig() {
    return `next.config.js`;
  },
  babelConfig() {
    return `babel.config.js`;
  },
  packageJson() {
    return "package.json";
  },
  prismaSchema() {
    return "db/schema.prisma";
  }
};

function addImport(program, importToAdd) {
  const importStatementCount = program.find(j__default.ImportDeclaration).length;
  if (importStatementCount === 0) {
    program.find(j__default.Statement).at(0).insertBefore(importToAdd);
    return program;
  }
  program.find(j__default.ImportDeclaration).forEach((stmt, idx) => {
    const node = stmt.node;
    if (idx === importStatementCount - 1) {
      stmt.replace(node, importToAdd);
    }
  });
  return program;
}

const addBlitzMiddleware = (program, middleware) => {
  const pluginArray = program.find(j__default.Identifier, (node) => node.name === "plugins");
  pluginArray.get().parentPath.value.value.elements = [
    ...pluginArray.get().parentPath.value.value.elements,
    j__default.template.expression`BlitzServerMiddleware(${middleware})`
  ];
  const blitzServerMiddleWare = j__default.importDeclaration(
    [j__default.importSpecifier(j__default.identifier("BlitzServerMiddleware"))],
    j__default.literal("blitz")
  );
  addImport(program, blitzServerMiddleWare);
  return program;
};

const findModuleExportsExpressions = (program) => program.find(j__default.AssignmentExpression).filter((path) => {
  const { left, right } = path.value;
  return left.type === "MemberExpression" && left.object.type === "Identifier" && left.property.type === "Identifier" && left.property.name === "exports" && right.type === "ObjectExpression";
});

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function produceSchema(source, producer) {
  return __async(this, null, function* () {
    const schema = yield prismaAst.getSchema(source);
    producer(schema);
    return prismaAst.printSchema(schema);
  });
}

function addPrismaEnum(source, enumProps) {
  return produceSchema(source, (schema) => {
    const existing = schema.list.find((x) => x.type === "enum" && x.name === enumProps.name);
    existing ? Object.assign(existing, enumProps) : schema.list.push(enumProps);
  });
}

function addPrismaField(source, modelName, fieldProps) {
  return produceSchema(source, (schema) => {
    const model = schema.list.find((x) => x.type === "model" && x.name === modelName);
    if (!model)
      return;
    const existing = model.properties.find((x) => x.type === "field" && x.name === fieldProps.name);
    existing ? Object.assign(existing, fieldProps) : model.properties.push(fieldProps);
  });
}

function addPrismaGenerator(source, generatorProps) {
  return produceSchema(source, (schema) => {
    const existing = schema.list.find(
      (x) => x.type === "generator" && x.name === generatorProps.name
    );
    existing ? Object.assign(existing, generatorProps) : schema.list.push(generatorProps);
  });
}

function addPrismaModelAttribute(source, modelName, attributeProps) {
  return produceSchema(source, (schema) => {
    const model = schema.list.find((x) => x.type === "model" && x.name === modelName);
    if (!model)
      return;
    const existing = model.properties.find(
      (x) => x.type === "attribute" && x.name === attributeProps.name
    );
    existing ? Object.assign(existing, attributeProps) : model.properties.push(attributeProps);
  });
}

function addPrismaModel(source, modelProps) {
  return produceSchema(source, (schema) => {
    const existing = schema.list.find((x) => x.type === "model" && x.name === modelProps.name);
    existing ? Object.assign(existing, modelProps) : schema.list.push(modelProps);
  });
}

function setPrismaDataSource(source, datasourceProps) {
  return produceSchema(source, (schema) => {
    const existing = schema.list.find((x) => x.type === "datasource");
    existing ? Object.assign(existing, datasourceProps) : schema.list.push(datasourceProps);
  });
}

function transformNextConfig(program) {
  const configObj = program.find(j__default.VariableDeclarator, (filter) => filter.id.name === "config").get().parentPath.value[0].init.properties;
  index.assert(configObj, "Config object not found");
  const pushToConfig = (property) => {
    configObj.push(property);
  };
  const wrapConfig = (func) => {
    const withBlitz = program.find(j__default.CallExpression, (filter) => filter.callee.name === "withBlitz").get().value.arguments;
    index.assert(withBlitz, "withBlitz wrapper not found");
    if (typeof func === "string") {
      withBlitz.push(j__default.template.expression`${func}(${withBlitz})`);
      withBlitz.splice(0, 1);
    } else {
      withBlitz.push(func);
      withBlitz.splice(0, 1);
    }
    return {
      withBlitz
    };
  };
  const addRequireStatement = (identifier, packageName) => {
    program.get().value.program.body.unshift(
      j__default.expressionStatement(
        j__default.assignmentExpression(
          "=",
          j__default.identifier(identifier),
          j__default.callExpression(j__default.identifier("require"), [j__default.identifier(`"${packageName}"`)])
        )
      )
    );
  };
  return {
    program,
    configObj,
    pushToConfig,
    wrapConfig,
    addRequireStatement
  };
}

function withComments(node, comments) {
  node.comments = comments;
  return node;
}
function withTypeAnnotation(node, type) {
  node.typeAnnotation = j__default.tsTypeAnnotation(type);
  return node;
}

function wrapBlitzConfig(program, functionName) {
  let moduleExportsExpressions = program.find(j__default.AssignmentExpression, {
    operator: "=",
    left: { object: { name: "module" }, property: { name: "exports" } },
    right: {}
  });
  if (moduleExportsExpressions.length === 0) {
    let moduleExportExpression = j__default.expressionStatement(
      j__default.assignmentExpression(
        "=",
        j__default.memberExpression(j__default.identifier("module"), j__default.identifier("exports")),
        j__default.callExpression(j__default.identifier(functionName), [j__default.objectExpression([])])
      )
    );
    program.get().node.program.body.push(moduleExportExpression);
  } else if (moduleExportsExpressions.length === 1) {
    let moduleExportsExpression = moduleExportsExpressions.get();
    moduleExportsExpression.value.right = j__default.callExpression(j__default.identifier(functionName), [
      moduleExportsExpression.value.right
    ]);
  } else {
    console.warn("There are multiple 'module.exports' inside 'blitz.config.js'");
  }
  return program;
}

const jsonValueToExpression = (value) => typeof value === "string" ? j__default.stringLiteral(value) : typeof value === "number" ? j__default.numericLiteral(value) : typeof value === "boolean" ? j__default.booleanLiteral(value) : value === null ? j__default.nullLiteral() : Array.isArray(value) ? j__default.arrayExpression(value.map(jsonValueToExpression)) : j__default.objectExpression(
  Object.entries(value).filter((entry) => entry[1] !== void 0).map(
    ([key, value2]) => j__default.objectProperty(j__default.stringLiteral(key), jsonValueToExpression(value2))
  )
);
function updateBabelConfig(program, item, key) {
  findModuleExportsExpressions(program).forEach((moduleExportsExpression) => {
    const foundExpression = j__default(moduleExportsExpression);
    foundExpression.find(j__default.ObjectProperty, { key: { name: key } }).forEach((items) => {
      var _a, _b, _c;
      const itemName = Array.isArray(item) ? item[0] : item;
      if (items.node.value.type === "Literal" || items.node.value.type === "StringLiteral") {
        if (itemName !== items.node.value.value) {
          items.node.value = j__default.arrayExpression([items.node.value, jsonValueToExpression(item)]);
        }
      } else if (items.node.value.type === "ArrayExpression") {
        for (const [i, element] of items.node.value.elements.entries()) {
          if (!element)
            continue;
          if (element.type === "Literal" || element.type === "StringLiteral") {
            if (element.value === itemName)
              return;
          } else if (element.type === "ArrayExpression") {
            if ((((_a = element.elements[0]) == null ? void 0 : _a.type) === "Literal" || ((_b = element.elements[0]) == null ? void 0 : _b.type) === "StringLiteral") && element.elements[0].value === itemName) {
              if (((_c = element.elements[1]) == null ? void 0 : _c.type) === "ObjectExpression" && element.elements[1].properties.length > 0) {
                if (Array.isArray(item)) {
                  let obj = element.elements[1];
                  for (const key2 in item[1]) {
                    const value = item[1][key2];
                    if (value === void 0)
                      continue;
                    obj.properties.push(
                      j__default.objectProperty(j__default.stringLiteral(key2), jsonValueToExpression(value))
                    );
                  }
                  items.node.value.elements[i] = obj;
                }
              } else {
                items.node.value.elements[i] = jsonValueToExpression(item);
              }
              return;
            }
          }
        }
        items.node.value.elements.push(jsonValueToExpression(item));
      }
    });
  });
  return program;
}
const addBabelPreset = (program, preset) => updateBabelConfig(program, preset, "presets");
const addBabelPlugin = (program, plugin) => updateBabelConfig(program, plugin, "plugins");

function wrapAppWithProvider(program, element, attributes) {
  const findMyApp = program.find(j__default.FunctionDeclaration, (node) => node.id.name === "MyApp");
  index.assert(findMyApp.length, "MyApp function not found");
  findMyApp.forEach((path) => {
    const statement = path.value.body.body.filter(
      (b) => b.type === "ReturnStatement"
    )[0];
    const argument = statement.argument;
    let attrs = [];
    if (attributes) {
      attrs = attributes.map((i) => j__default.jsxAttribute(j__default.jsxIdentifier(i)));
    }
    statement.argument = j__default.jsxElement(
      j__default.jsxOpeningElement(j__default.jsxIdentifier(element), attrs),
      j__default.jsxClosingElement(j__default.jsxIdentifier(element)),
      [j__default.jsxText("\n"), argument, j__default.jsxText("\n")]
    );
  });
  return program;
}

exports.AddDependencyType = type$4;
exports.FileTransformType = type$3;
exports.Frontmatter = Frontmatter;
exports.NewFileType = type$2;
exports.PrintMessageType = type$1;
exports.RecipeBuilder = RecipeBuilder;
exports.RecipeExecutor = RecipeExecutor;
exports.addBabelPlugin = addBabelPlugin;
exports.addBabelPreset = addBabelPreset;
exports.addBlitzMiddleware = addBlitzMiddleware;
exports.addImport = addImport;
exports.addPrismaEnum = addPrismaEnum;
exports.addPrismaField = addPrismaField;
exports.addPrismaGenerator = addPrismaGenerator;
exports.addPrismaModel = addPrismaModel;
exports.addPrismaModelAttribute = addPrismaModelAttribute;
exports.customTsParser = customTsParser;
exports.findModuleExportsExpressions = findModuleExportsExpressions;
exports.getExecutorArgument = getExecutorArgument;
exports.paths = paths;
exports.produceSchema = produceSchema;
exports.setPrismaDataSource = setPrismaDataSource;
exports.transformNextConfig = transformNextConfig;
exports.withComments = withComments;
exports.withTypeAnnotation = withTypeAnnotation;
exports.wrapAppWithProvider = wrapAppWithProvider;
exports.wrapBlitzConfig = wrapBlitzConfig;
