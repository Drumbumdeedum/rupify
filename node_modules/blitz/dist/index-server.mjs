import { PaginationArgumentError } from './index-browser.mjs';
export { AuthenticationError, AuthorizationError, CSRFTokenMismatchError, NotFoundError, PaginationArgumentError, RedirectError, createClientPlugin, enhancePrisma, formatZodError, isRouteUrlObject, recursiveFormatZodErrors, validateZodSchema } from './index-browser.mjs';
export { r as runPrisma } from './chunks/run-prisma.mjs';
import 'p-event';
import 'cross-spawn';
import 'resolve-from';
import 'npm-which';
export { B as BlitzLogger, b as baseLogger, c as chalk, i as initializeLogger, l as log, n as newLine, t as table } from './chunks/logging.mjs';
export { s as startWatcher, a as stopWatcher } from './chunks/routes-manifest.mjs';
import { k as compose } from './chunks/index.mjs';
export { f as addMilliseconds, g as addMinutes, h as addYears, a as assert, k as compose, j as deleteCookie, d as differenceInMilliseconds, e as differenceInMinutes, l as interopDefault, b as isClient, c as isPast, i as isServer, p as prettyMs, r as readCookie, s as setCookie, t as truncateString } from './chunks/index.mjs';
import 'superjson';
import 'tslog';
import 'chalk';
import 'console-table-printer';
import 'ora';
import 'readline';
import 'path';
import 'os';
import 'fs';
import 'fs-extra';
import 'find-up';
import 'watchpack';
import './chunks/helpers.mjs';

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function handleRequestWithMiddleware(_0, _1, _2) {
  return __async$1(this, arguments, function* (req, res, middleware, {
    throwOnError = true,
    stackPrintOnError = true
  } = {}) {
    if (!res.blitzCtx) {
      res.blitzCtx = {};
    }
    if (!res._blitz) {
      res._blitz = {};
    }
    let handler = compose(middleware);
    try {
      yield handler(req, res, (error) => {
        if (error) {
          throw error;
        }
      });
    } catch (error) {
      console.log("\n");
      if (res.writableFinished) {
        console.error(
          "Error occured in middleware after the response was already sent to the browser"
        );
      } else {
        console.error("Error while processing the request");
      }
      if (error._clearStack) {
        delete error.stack;
      }
      console.error(error);
      console.log("\n");
      if (throwOnError)
        throw error;
    }
  });
}
function noCallbackHandler(req, res, next, middleware) {
  middleware(req, res);
  return next();
}
function withCallbackHandler(req, res, next, middleware) {
  return new Promise((resolve, reject) => {
    middleware(req, res, (err) => {
      if (err)
        reject(err);
      else
        resolve(next());
    });
  });
}
function connectMiddleware(middleware) {
  const handler = middleware.length < 3 ? noCallbackHandler : withCallbackHandler;
  return function connectHandler(req, res, next) {
    return handler(req, res, next, middleware);
  };
}
const secureProxyMiddleware = function(req, _res, next) {
  req.protocol = "https";
  next();
};

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const isInteger = (value) => typeof value === "number" && value % 1 === 0;
function paginate(_0) {
  return __async(this, arguments, function* ({
    skip = 0,
    take = 0,
    maxTake = 250,
    count: countQuery,
    query
  }) {
    if (!isInteger(skip)) {
      throw new PaginationArgumentError("`skip` argument must be a integer");
    }
    if (!isInteger(take)) {
      throw new PaginationArgumentError("`take` argument must be a integer");
    }
    if (!isInteger(maxTake)) {
      throw new PaginationArgumentError("`maxTake` argument must be a integer");
    }
    if (typeof countQuery !== "function") {
      throw new PaginationArgumentError("`count` argument must be a function");
    }
    if (typeof query !== "function") {
      throw new PaginationArgumentError("`query` argument must be a function");
    }
    if (skip < 0) {
      throw new PaginationArgumentError("`skip` argument must be a positive number");
    }
    if (take < 0) {
      throw new PaginationArgumentError("`take` argument must be a positive number");
    }
    if (take > maxTake) {
      throw new PaginationArgumentError(
        "`take` argument must less than `maxTake` which is currently " + maxTake
      );
    }
    const [count, items] = yield Promise.all([countQuery(), query({ skip, take })]);
    const hasMore = skip + take < count;
    const nextPage = hasMore ? { take, skip: skip + take } : null;
    const pageCount = Math.floor((count + take - 1) / take);
    const from = skip + 1;
    const to = skip + take;
    return {
      items,
      nextPage,
      hasMore,
      pageCount,
      pageSize: take,
      from,
      to,
      count
    };
  });
}

function createServerPlugin(pluginConstructor) {
  return pluginConstructor;
}
function createSetupServer(setupServerConstructor) {
  return setupServerConstructor;
}
const BlitzServerMiddleware = (middleware) => ({
  requestMiddlewares: [middleware]
});

export { BlitzServerMiddleware, connectMiddleware, createServerPlugin, createSetupServer, handleRequestWithMiddleware, noCallbackHandler, paginate, secureProxyMiddleware, withCallbackHandler };
