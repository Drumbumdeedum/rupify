'use strict';

const index = require('./index2.cjs');
const spawn = require('cross-spawn');
const detect = require('detect-port');
const path = require('path');
const fs = require('fs-extra');
const esbuild = require('esbuild');
const pkgDir = require('pkg-dir');
const fs$1 = require('fs');
const codegenTasks = require('./codegen-tasks.cjs');
require('arg');
require('dotenv');
require('dotenv-expand');
require('resolve-cwd');
require('resolve-from');
require('./helpers.cjs');
require('./routes-manifest.cjs');
require('os');
require('find-up');
require('watchpack');
require('./logging.cjs');
require('tslog');
require('chalk');
require('console-table-printer');
require('ora');
require('readline');
require('./run-prisma.cjs');
require('p-event');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const detect__default = /*#__PURE__*/_interopDefaultLegacy(detect);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const path__namespace = /*#__PURE__*/_interopNamespace(path);
const esbuild__namespace = /*#__PURE__*/_interopNamespace(esbuild);
const pkgDir__default = /*#__PURE__*/_interopDefaultLegacy(pkgDir);
const fs__namespace = /*#__PURE__*/_interopNamespace(fs$1);

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug = require("debug")("blitz:utils");
function getProjectRootSync() {
  return process.cwd();
}
function getCustomServerPath() {
  const projectRoot = getProjectRootSync();
  let serverPath = path__default.resolve(path__default.join(projectRoot, "server.ts"));
  if (fs.existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server.js"));
  if (fs.existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server/index.ts"));
  if (fs.existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server/index.js"));
  if (fs.existsSync(serverPath))
    return serverPath;
  throw new Error("Unable to find custom server");
}
function customServerExists() {
  try {
    getCustomServerPath();
    return true;
  } catch (e) {
    return false;
  }
}
function getCustomServerBuildPath() {
  const projectRoot = getProjectRootSync();
  return path__default.resolve(projectRoot, ".next", "custom-server.js");
}
const getEsbuildOptions = () => {
  var _a, _b;
  const pkg = fs.readJSONSync(path__default.join(pkgDir__default.sync(), "package.json"));
  return {
    entryPoints: [getCustomServerPath()],
    outfile: getCustomServerBuildPath(),
    format: "cjs",
    target: "es6",
    bundle: true,
    platform: "node",
    external: [
      "blitz",
      "next",
      ...Object.keys(require("blitz/package").dependencies),
      ...Object.keys((_a = pkg == null ? void 0 : pkg.dependencies) != null ? _a : {}),
      ...Object.keys((_b = pkg == null ? void 0 : pkg.devDependencies) != null ? _b : {})
    ]
  };
};
function startCustomServer(_cwd, config, { watch } = {}) {
  process.env.BLITZ_APP_DIR = config.rootFolder;
  const serverBuildPath = getCustomServerBuildPath();
  let spawnEnv = getSpawnEnv(config);
  if (config.env === "prod") {
    spawnEnv = __spreadProps$1(__spreadValues$1({}, spawnEnv), { NODE_ENV: "production" });
  }
  return new Promise((res, rej) => {
    let process2;
    const RESTART_CODE = 777777;
    const spawnServer = () => {
      process2 = spawn.spawn("node", [serverBuildPath], {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else if (watch && code === RESTART_CODE) {
          spawnServer();
        } else {
          rej(`server.js failed with status code: ${code}`);
        }
      }).on("error", (err) => {
        console.error(err);
        rej(err);
      });
    };
    const skipDevCustomServerBuild = config.env === "prod";
    if (skipDevCustomServerBuild) {
      spawnServer();
      return;
    }
    const esbuildOptions = getEsbuildOptions();
    esbuildOptions.watch = watch ? {
      onRebuild(error) {
        if (error) {
          console.error("Failed to re-build custom server");
        } else {
          console.log("\n");
          console.log("Custom server changed - restarting...");
          console.log("\n");
          process2.exitCode = RESTART_CODE;
          process2.kill("SIGABRT");
        }
      }
    } : void 0;
    esbuild__namespace.build(esbuildOptions).then(() => {
      spawnServer();
    });
  });
}
function getSpawnEnv(config) {
  let spawnEnv = process.env;
  spawnEnv.FORCE_COLOR = "3";
  if (config.inspect) {
    spawnEnv = __spreadProps$1(__spreadValues$1({}, spawnEnv), { NODE_OPTIONS: "--inspect" });
  }
  return spawnEnv;
}
function createCommandAndPort(config, command) {
  return __async$1(this, null, function* () {
    let spawnCommand = [command];
    let availablePort;
    availablePort = yield detect__default({ port: config.port ? config.port : 3e3 });
    spawnCommand = spawnCommand.concat(["-p", `${availablePort}`]);
    if (config.hostname) {
      spawnCommand = spawnCommand.concat(["-H", `${config.hostname}`]);
    }
    const spawnEnv = getSpawnEnv(config);
    return { spawnCommand, spawnEnv, availablePort };
  });
}
function nextStartDev(nextBin, cwd, _manifest, _buildFolder, config) {
  return __async$1(this, null, function* () {
    const { spawnCommand, spawnEnv, availablePort } = yield createCommandAndPort(config, "dev");
    process.env.BLITZ_DEV_SERVER_ORIGIN = `http://localhost:${availablePort}`;
    debug("cwd ", cwd);
    debug("spawn ", nextBin, spawnCommand);
    return new Promise((res, rej) => {
      spawn.spawn(nextBin, spawnCommand, {
        cwd,
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", rej);
    });
  });
}
function nextBuild(nextBin, _buildFolder, _manifest, config) {
  const spawnEnv = getSpawnEnv(config);
  return new Promise((res, rej) => {
    spawn.spawn(nextBin, ["build"], {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", (code) => {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
function nextExport(nextBin, config) {
  const spawnEnv = getSpawnEnv(config);
  const args = ["export"];
  if (config.outdir) {
    args.push("-o", `${config.outdir}`);
  }
  return new Promise((res, rej) => {
    spawn.spawn(nextBin, args, {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", (code) => {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
function nextStart(nextBin, _buildFolder, config) {
  return __async$1(this, null, function* () {
    const { spawnCommand, spawnEnv } = yield createCommandAndPort(config, "start");
    return new Promise((res, rej) => {
      spawn.spawn(nextBin, spawnCommand, {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", (err) => {
        console.error(err);
        rej(err);
      });
    });
  });
}
function buildCustomServer({ watch } = {}) {
  const esbuildOptions = getEsbuildOptions();
  if (watch) {
    esbuildOptions.watch = {
      onRebuild(error) {
        if (error) {
          console.error("Failed to re-build custom server");
        } else {
          console.log("\n");
          console.log("Custom server changed - rebuilding...");
        }
      }
    };
  }
  return esbuild__namespace.build(esbuildOptions);
}

function readBlitzConfig(rootFolder = process.cwd()) {
  const nextConfigFile = fs__namespace.readFileSync(path__namespace.join(rootFolder, "next.config.js"), {
    encoding: "utf8",
    flag: "r"
  });
  const nextConfig = eval(nextConfigFile);
  return nextConfig.blitz || {};
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function build(config) {
  return __async(this, null, function* () {
    const { rootFolder, nextBin, watch } = yield index.normalize(config);
    yield codegenTasks.codegenTasks();
    yield nextBuild(nextBin, rootFolder, {}, config);
    if (customServerExists())
      yield buildCustomServer({ watch });
  });
}
function dev(config) {
  return __async(this, null, function* () {
    var _a, _b;
    const { rootFolder, nextBin } = yield index.normalize(__spreadProps(__spreadValues({}, config), { env: "dev" }));
    yield codegenTasks.codegenTasks();
    if (customServerExists()) {
      console.log("Using your custom server");
      const blitzConfig = readBlitzConfig(rootFolder);
      const watch = (_b = (_a = blitzConfig.customServer) == null ? void 0 : _a.hotReload) != null ? _b : true;
      yield startCustomServer(rootFolder, config, { watch });
    } else {
      yield nextStartDev(nextBin, rootFolder, {}, rootFolder, config);
    }
  });
}
function prod(config) {
  return __async(this, null, function* () {
    const { rootFolder, nextBin } = yield index.normalize(config);
    if (customServerExists()) {
      console.log("Using your custom server");
      yield startCustomServer(rootFolder, config);
    } else {
      yield nextStart(nextBin, rootFolder, config);
    }
  });
}
function blitzExport(config) {
  return __async(this, null, function* () {
    const { nextBin } = yield index.normalize(config);
    yield nextExport(nextBin, config);
  });
}

exports.blitzExport = blitzExport;
exports.build = build;
exports.dev = dev;
exports.prod = prod;
