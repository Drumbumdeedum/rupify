'use strict';

const pEvent = require('p-event');
const spawn = require('cross-spawn');
const resolveFrom = require('resolve-from');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const pEvent__default = /*#__PURE__*/_interopDefaultLegacy(pEvent);
const resolveFrom__default = /*#__PURE__*/_interopDefaultLegacy(resolveFrom);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const runPrisma = (args, silent = false) => __async(void 0, null, function* () {
  var _a;
  const prismaBin = resolveFrom__default.silent(process.cwd(), "prisma");
  if (prismaBin) {
    const cp = spawn.spawn(prismaBin, args, {
      stdio: silent ? "pipe" : "inherit",
      env: process.env
    });
    const cp_stderr = [];
    if (silent) {
      (_a = cp == null ? void 0 : cp.stderr) == null ? void 0 : _a.on("data", (chunk) => {
        cp_stderr.push(chunk.toString());
      });
    }
    const code = yield pEvent__default(cp, "exit", { rejectionEvents: [] });
    return {
      success: code === 0,
      stderr: silent ? cp_stderr.join("") : void 0
    };
  } else {
    return {
      success: false
    };
  }
});

exports.runPrisma = runPrisma;
