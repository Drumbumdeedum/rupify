import arg from 'arg';
import spawn from 'cross-spawn';
import * as fs from 'fs';
import fs__default, { promises } from 'fs';
import * as path from 'path';
import path__default, { join, resolve } from 'path';
import * as dotenv from 'dotenv';
import dotenvExpand from 'dotenv-expand';
import { readJSON } from 'fs-extra';
import pkgDir from 'pkg-dir';
import resolveCwd from 'resolve-cwd';
import resolveFrom from 'resolve-from';
import { g as getPkgManager } from './helpers.mjs';

let combinedEnv = void 0;
let cachedLoadedEnvFiles = [];
function processEnv(loadedEnvFiles, dir, log = console) {
  var _a;
  if (process.env.__NEXT_PROCESSED_ENV || loadedEnvFiles.length === 0) {
    return process.env;
  }
  process.env.__NEXT_PROCESSED_ENV = "true";
  const origEnv = Object.assign({}, process.env);
  const parsed = {};
  for (const envFile of loadedEnvFiles) {
    try {
      let result = {};
      result.parsed = dotenv.parse(envFile.contents);
      result = dotenvExpand.expand(result);
      if (result.parsed) {
        log.info(`Loaded env from ${path.join(dir || "", envFile.path)}`);
      }
      for (const key of Object.keys(result.parsed || {})) {
        if (typeof parsed[key] === "undefined" && typeof origEnv[key] === "undefined") {
          parsed[key] = (_a = result.parsed) == null ? void 0 : _a[key];
        }
      }
    } catch (err) {
      log.error(`Failed to load env from ${path.join(dir || "", envFile.path)}`, err);
    }
  }
  return Object.assign(process.env, parsed);
}
function loadEnvConfig(dir = process.cwd(), _dev, log = console, { ignoreCache } = { ignoreCache: false }) {
  var _a, _b;
  if (combinedEnv && !ignoreCache)
    return { combinedEnv, loadedEnvFiles: cachedLoadedEnvFiles };
  const appEnv = (_b = (_a = process.env.APP_ENV) != null ? _a : process.env.NODE_ENV) != null ? _b : "development";
  let dotenvFiles = [
    `.env.${appEnv}.local`,
    `.env.${appEnv}`,
    appEnv !== "test" && `.env.local`,
    ".env"
  ].filter(Boolean);
  for (const envFile of dotenvFiles) {
    const dotEnvPath = path.join(dir, envFile);
    try {
      const stats = fs.statSync(dotEnvPath);
      if (!stats.isFile()) {
        continue;
      }
      const contents = fs.readFileSync(dotEnvPath, "utf8");
      cachedLoadedEnvFiles.push({
        path: envFile,
        contents
      });
    } catch (err) {
      if (err.code !== "ENOENT") {
        log.error(`Failed to load env from ${envFile}`, err);
      }
    }
  }
  combinedEnv = processEnv(cachedLoadedEnvFiles, dir, log);
  return { combinedEnv, loadedEnvFiles: cachedLoadedEnvFiles };
}

const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug = require("debug")("blitz:utils");
function resolveBinAsync(_0) {
  return __async$1(this, arguments, function* (pkg, executable = pkg) {
    const packageDir = yield pkgDir(resolveCwd(pkg));
    if (!packageDir)
      throw new Error(`Could not find package.json for '${pkg}'`);
    const { bin } = yield readJSON(path__default.join(packageDir, "package.json"));
    const binPath = typeof bin === "object" ? bin[executable] : bin;
    if (!binPath)
      throw new Error(`No bin '${executable}' in module '${pkg}'`);
    debug("binPath: " + binPath);
    const fullPath = path__default.join(packageDir, binPath);
    debug("fullPath: " + fullPath);
    return fullPath;
  });
}
function isInDocker() {
  const cgroupFile = join("proc", "self", "cgroup");
  if (fs__default.existsSync(cgroupFile)) {
    const content = fs__default.readFileSync(cgroupFile, "utf-8");
    return content.includes("docker");
  }
  return false;
}
const defaults = {
  hostname: isInDocker() ? "0.0.0.0" : "127.0.0.1",
  env: "prod"
};
function normalize(config) {
  return __async$1(this, null, function* () {
    var _a, _b, _c;
    const rootFolder = resolve(process.cwd(), config.rootFolder);
    const env = config.env || defaults.env;
    return __spreadProps(__spreadValues({}, config), {
      hostname: (_a = config.hostname) != null ? _a : defaults.hostname,
      env,
      rootFolder,
      isTypeScript: (_b = config.isTypeScript) != null ? _b : yield getIsTypeScript(rootFolder),
      watch: (_c = config.watch) != null ? _c : env === "dev",
      clean: config.clean,
      nextBin: yield getCommandBin("next", rootFolder, env === "dev")
    });
  });
}
function getCommandBin(_0) {
  return __async$1(this, arguments, function* (command, rootFolder = process.cwd(), _usePatched = false) {
    const bin = yield resolveBinAsync(command);
    return resolve(rootFolder, bin);
  });
}
function getIsTypeScript(rootFolder) {
  return __async$1(this, null, function* () {
    try {
      yield promises.access(join(rootFolder, "tsconfig.json"));
      return true;
    } catch (e) {
      return false;
    }
  });
}

const globalBlitzPath = resolveFrom.silent(__dirname, "blitz");
const localBlitzPath = resolveFrom.silent(process.cwd(), "blitz");
const localBlitzAuthPath = resolveFrom.silent(process.cwd(), "@blitzjs/auth");
const localBlitzRpcPath = resolveFrom.silent(process.cwd(), "@blitzjs/rpc");
const localBlitzNextPath = resolveFrom.silent(process.cwd(), "@blitzjs/next");
function readVersions() {
  const globalBlitzPkgJsonPath = pkgDir.sync(globalBlitzPath);
  const localBlitzPkgJsonPath = pkgDir.sync(localBlitzPath);
  const localBlitzAuthPkgJsonPath = pkgDir.sync(localBlitzAuthPath);
  const localBlitzNextPkgJsonPath = pkgDir.sync(localBlitzNextPath);
  const localBlitzRpcPkgJsonPath = pkgDir.sync(localBlitzRpcPath);
  const versions = { globalVersion: "", localVersions: {} };
  if (globalBlitzPkgJsonPath && globalBlitzPkgJsonPath !== localBlitzPkgJsonPath) {
    versions.globalVersion = require(join(globalBlitzPkgJsonPath, "package.json")).version;
  }
  if (localBlitzPkgJsonPath) {
    versions.localVersions.blitz = require(join(localBlitzPkgJsonPath, "package.json")).version;
  }
  if (localBlitzAuthPkgJsonPath) {
    versions.localVersions.blitzAuth = require(join(
      localBlitzAuthPkgJsonPath,
      "package.json"
    )).version;
  }
  if (localBlitzNextPkgJsonPath) {
    versions.localVersions.blitzNext = require(join(
      localBlitzNextPkgJsonPath,
      "package.json"
    )).version;
  }
  if (localBlitzRpcPkgJsonPath) {
    versions.localVersions.blitzRpc = require(join(
      localBlitzRpcPkgJsonPath,
      "package.json"
    )).version;
  }
  return versions;
}

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const commonArgs = {
  "--version": Boolean,
  "--help": Boolean,
  "--inspect": Boolean,
  "--env": String,
  "-v": "--version",
  "-h": "--help",
  "-e": "--env"
};
const args = arg(commonArgs, {
  permissive: true
});
const commands = {
  dev: () => import('./dev.mjs').then((i) => i.dev),
  build: () => import('./build.mjs').then((i) => i.build),
  start: () => import('./start.mjs').then((i) => i.start),
  export: () => import('./export.mjs').then((i) => i.nextExport),
  new: () => import('./new.mjs').then((i) => i.newApp),
  generate: () => import('./generate.mjs').then((i) => i.generate),
  codegen: () => import('./codegen.mjs').then((i) => i.codegen),
  db: () => import('./db.mjs').then((i) => i.db),
  install: () => import('./install.mjs').then((i) => i.install),
  console: () => import('./console.mjs').then((i) => i.consoleREPL),
  routes: () => import('./routes.mjs').then((i) => i.routes)
};
const aliases = {
  d: "dev",
  b: "build",
  s: "start",
  e: "export",
  n: "new",
  g: "generate",
  i: "install",
  c: "console",
  r: "routes"
};
let blitzCommand;
if (commands[args._[0]]) {
  blitzCommand = args._[0];
}
if (aliases[args._[0]]) {
  blitzCommand = aliases[args._[0]];
}
const forwardedArgs = blitzCommand ? args._.slice(1) : args._;
function runCommandFromBin() {
  return __async(this, null, function* () {
    if (!args._[0]) {
      console.log("No command specified");
      process.exit(1);
    }
    let commandBin = null;
    try {
      commandBin = yield getCommandBin(args._[0]);
    } catch (e) {
      console.error(`Error: ${e.message}`);
    }
    if (!commandBin) {
      process.exit(1);
    }
    const result = spawn.sync(commandBin, args._.slice(1), { stdio: "inherit" });
    process.exit(result.status || 0);
  });
}
function printEnvInfo() {
  return __async(this, null, function* () {
    const osName = yield import('os-name');
    const envinfo = yield import('envinfo');
    const pkgManager = getPkgManager();
    const env = yield envinfo.default.run(
      {
        System: ["OS", "CPU", "Memory", "Shell"],
        Binaries: ["Node", "Yarn", "npm", "pnpm"],
        npmPackages: [
          "blitz",
          "@blitzjs/rpc",
          "@blitzjs/auth",
          "@blitzjs/next",
          "typescript",
          "react",
          "react-dom",
          "prisma",
          "@prisma/client",
          "next"
        ]
      },
      { showNotFound: true }
    );
    const { globalVersion, localVersions } = readVersions();
    if (globalVersion) {
      console.log(`Blitz version: ${globalVersion} (global)`);
    }
    if (localVersions.blitz) {
      console.log(`Blitz version: ${localVersions.blitz} (local)`);
    }
    console.log(
      `${osName.default()} | ${process.platform}-${process.arch} | Node: ${process.version}
`
    );
    console.log(`
 Package manager: ${pkgManager}`);
    console.log(env);
    process.exit(0);
  });
}
function main() {
  return __async(this, null, function* () {
    if (args["--env"]) {
      process.env.APP_ENV = args["--env"];
    }
    if (args["_"].length === 0 && args["--version"]) {
      yield printEnvInfo();
    }
    if (args["--help"]) {
      forwardedArgs.push("--help");
    }
    const defaultEnv = blitzCommand === "build" || blitzCommand === "start" ? "production" : "development";
    const standardEnv = ["production", "development", "test"];
    if (process.env.NODE_ENV && !standardEnv.includes(process.env.NODE_ENV)) {
      console.warn(NON_STANDARD_NODE_ENV);
    }
    process.env.NODE_ENV = process.env.NODE_ENV || defaultEnv;
    loadEnvConfig(process.cwd(), void 0, { error: console.error, info: console.info });
    process.on("SIGTERM", () => process.exit(0));
    process.on("SIGINT", () => process.exit(0));
    if (blitzCommand) {
      const commandFn = commands[blitzCommand];
      commandFn == null ? void 0 : commandFn().then((exec) => exec(forwardedArgs)).then(() => {
        if (blitzCommand === "build") {
          process.exit(0);
        }
      }).catch((err) => {
        console.log(err);
      });
    } else {
      if (args["--help"] && forwardedArgs.length === 1 && forwardedArgs[0] === "--help") {
        console.log(`
      Usage
        $ blitz <command>
  
      Available commands
        dev, d          Start a development server \u{1F984} 
        build, b        Create a production build \u{1F3D7}\uFE0F
        start, s        Start the production server \u{1F40E}
        export, e       Export application to static HTML \u{1F4C1}
        new, n          Create a new Blitz project \u2728
        generate, g     Generate new files for your Blitz project \u{1F920}
        codegen         Run the blitz codegen \u{1F916}
        db              Run database commands \u{1F5C4}\uFE0F
        
      Options
        --env, -e       App environment name
        --version, -v   Version number
        --help, -h      Displays this message
  
      For more information run a command with the --help flag
        $ blitz build --help
    `);
        process.exit(0);
      } else {
        void runCommandFromBin();
      }
    }
  });
}
main().catch((e) => {
  console.error(e);
});

export { loadEnvConfig as l, normalize as n, readVersions as r };
