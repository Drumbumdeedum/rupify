import { n as normalize } from './index2.mjs';
import { spawn } from 'cross-spawn';
import detect from 'detect-port';
import * as path from 'path';
import path__default from 'path';
import { existsSync, readJSONSync } from 'fs-extra';
import * as esbuild from 'esbuild';
import pkgDir from 'pkg-dir';
import * as fs from 'fs';
import { c as codegenTasks } from './codegen-tasks.mjs';
import 'arg';
import 'dotenv';
import 'dotenv-expand';
import 'resolve-cwd';
import 'resolve-from';
import './helpers.mjs';
import './routes-manifest.mjs';
import 'os';
import 'find-up';
import 'watchpack';
import './logging.mjs';
import 'tslog';
import 'chalk';
import 'console-table-printer';
import 'ora';
import 'readline';
import './run-prisma.mjs';
import 'p-event';

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug = require("debug")("blitz:utils");
function getProjectRootSync() {
  return process.cwd();
}
function getCustomServerPath() {
  const projectRoot = getProjectRootSync();
  let serverPath = path__default.resolve(path__default.join(projectRoot, "server.ts"));
  if (existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server.js"));
  if (existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server/index.ts"));
  if (existsSync(serverPath))
    return serverPath;
  serverPath = path__default.resolve(path__default.join(projectRoot, "server/index.js"));
  if (existsSync(serverPath))
    return serverPath;
  throw new Error("Unable to find custom server");
}
function customServerExists() {
  try {
    getCustomServerPath();
    return true;
  } catch (e) {
    return false;
  }
}
function getCustomServerBuildPath() {
  const projectRoot = getProjectRootSync();
  return path__default.resolve(projectRoot, ".next", "custom-server.js");
}
const getEsbuildOptions = () => {
  var _a, _b;
  const pkg = readJSONSync(path__default.join(pkgDir.sync(), "package.json"));
  return {
    entryPoints: [getCustomServerPath()],
    outfile: getCustomServerBuildPath(),
    format: "cjs",
    target: "es6",
    bundle: true,
    platform: "node",
    external: [
      "blitz",
      "next",
      ...Object.keys(require("blitz/package").dependencies),
      ...Object.keys((_a = pkg == null ? void 0 : pkg.dependencies) != null ? _a : {}),
      ...Object.keys((_b = pkg == null ? void 0 : pkg.devDependencies) != null ? _b : {})
    ]
  };
};
function startCustomServer(_cwd, config, { watch } = {}) {
  process.env.BLITZ_APP_DIR = config.rootFolder;
  const serverBuildPath = getCustomServerBuildPath();
  let spawnEnv = getSpawnEnv(config);
  if (config.env === "prod") {
    spawnEnv = __spreadProps$1(__spreadValues$1({}, spawnEnv), { NODE_ENV: "production" });
  }
  return new Promise((res, rej) => {
    let process2;
    const RESTART_CODE = 777777;
    const spawnServer = () => {
      process2 = spawn("node", [serverBuildPath], {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else if (watch && code === RESTART_CODE) {
          spawnServer();
        } else {
          rej(`server.js failed with status code: ${code}`);
        }
      }).on("error", (err) => {
        console.error(err);
        rej(err);
      });
    };
    const skipDevCustomServerBuild = config.env === "prod";
    if (skipDevCustomServerBuild) {
      spawnServer();
      return;
    }
    const esbuildOptions = getEsbuildOptions();
    esbuildOptions.watch = watch ? {
      onRebuild(error) {
        if (error) {
          console.error("Failed to re-build custom server");
        } else {
          console.log("\n");
          console.log("Custom server changed - restarting...");
          console.log("\n");
          process2.exitCode = RESTART_CODE;
          process2.kill("SIGABRT");
        }
      }
    } : void 0;
    esbuild.build(esbuildOptions).then(() => {
      spawnServer();
    });
  });
}
function getSpawnEnv(config) {
  let spawnEnv = process.env;
  spawnEnv.FORCE_COLOR = "3";
  if (config.inspect) {
    spawnEnv = __spreadProps$1(__spreadValues$1({}, spawnEnv), { NODE_OPTIONS: "--inspect" });
  }
  return spawnEnv;
}
function createCommandAndPort(config, command) {
  return __async$1(this, null, function* () {
    let spawnCommand = [command];
    let availablePort;
    availablePort = yield detect({ port: config.port ? config.port : 3e3 });
    spawnCommand = spawnCommand.concat(["-p", `${availablePort}`]);
    if (config.hostname) {
      spawnCommand = spawnCommand.concat(["-H", `${config.hostname}`]);
    }
    const spawnEnv = getSpawnEnv(config);
    return { spawnCommand, spawnEnv, availablePort };
  });
}
function nextStartDev(nextBin, cwd, _manifest, _buildFolder, config) {
  return __async$1(this, null, function* () {
    const { spawnCommand, spawnEnv, availablePort } = yield createCommandAndPort(config, "dev");
    process.env.BLITZ_DEV_SERVER_ORIGIN = `http://localhost:${availablePort}`;
    debug("cwd ", cwd);
    debug("spawn ", nextBin, spawnCommand);
    return new Promise((res, rej) => {
      spawn(nextBin, spawnCommand, {
        cwd,
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", rej);
    });
  });
}
function nextBuild(nextBin, _buildFolder, _manifest, config) {
  const spawnEnv = getSpawnEnv(config);
  return new Promise((res, rej) => {
    spawn(nextBin, ["build"], {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", (code) => {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
function nextExport(nextBin, config) {
  const spawnEnv = getSpawnEnv(config);
  const args = ["export"];
  if (config.outdir) {
    args.push("-o", `${config.outdir}`);
  }
  return new Promise((res, rej) => {
    spawn(nextBin, args, {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", (code) => {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
function nextStart(nextBin, _buildFolder, config) {
  return __async$1(this, null, function* () {
    const { spawnCommand, spawnEnv } = yield createCommandAndPort(config, "start");
    return new Promise((res, rej) => {
      spawn(nextBin, spawnCommand, {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", (code) => {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", (err) => {
        console.error(err);
        rej(err);
      });
    });
  });
}
function buildCustomServer({ watch } = {}) {
  const esbuildOptions = getEsbuildOptions();
  if (watch) {
    esbuildOptions.watch = {
      onRebuild(error) {
        if (error) {
          console.error("Failed to re-build custom server");
        } else {
          console.log("\n");
          console.log("Custom server changed - rebuilding...");
        }
      }
    };
  }
  return esbuild.build(esbuildOptions);
}

function readBlitzConfig(rootFolder = process.cwd()) {
  const nextConfigFile = fs.readFileSync(path.join(rootFolder, "next.config.js"), {
    encoding: "utf8",
    flag: "r"
  });
  const nextConfig = eval(nextConfigFile);
  return nextConfig.blitz || {};
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function build(config) {
  return __async(this, null, function* () {
    const { rootFolder, nextBin, watch } = yield normalize(config);
    yield codegenTasks();
    yield nextBuild(nextBin, rootFolder, {}, config);
    if (customServerExists())
      yield buildCustomServer({ watch });
  });
}
function dev(config) {
  return __async(this, null, function* () {
    var _a, _b;
    const { rootFolder, nextBin } = yield normalize(__spreadProps(__spreadValues({}, config), { env: "dev" }));
    yield codegenTasks();
    if (customServerExists()) {
      console.log("Using your custom server");
      const blitzConfig = readBlitzConfig(rootFolder);
      const watch = (_b = (_a = blitzConfig.customServer) == null ? void 0 : _a.hotReload) != null ? _b : true;
      yield startCustomServer(rootFolder, config, { watch });
    } else {
      yield nextStartDev(nextBin, rootFolder, {}, rootFolder, config);
    }
  });
}
function prod(config) {
  return __async(this, null, function* () {
    const { rootFolder, nextBin } = yield normalize(config);
    if (customServerExists()) {
      console.log("Using your custom server");
      yield startCustomServer(rootFolder, config);
    } else {
      yield nextStart(nextBin, rootFolder, config);
    }
  });
}
function blitzExport(config) {
  return __async(this, null, function* () {
    const { nextBin } = yield normalize(config);
    yield nextExport(nextBin, config);
  });
}

export { blitzExport, build, dev, prod };
