import { join, dirname } from 'path';
import os from 'os';
import { promises } from 'fs';
import { readdir, outputFile } from 'fs-extra';
import findUp from 'find-up';
import resolveFrom from 'resolve-from';
import Watchpack from 'watchpack';
import { i as isInternalBlitzMonorepoDevelopment } from './helpers.mjs';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const readFile = promises.readFile;
const NEXT_CONFIG_FILE = "next.config.js";
const PHASE_PRODUCTION_SERVER = "phase-production-server";
const PAGES_DIR_ALIAS = "private-next-pages";
const imageConfigDefault = {
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  path: "/_next/image",
  loader: "default",
  domains: [],
  disableStaticImages: false,
  minimumCacheTTL: 60
};
const defaultConfig = {
  env: {},
  webpack: null,
  webpackDevMiddleware: null,
  distDir: ".next",
  cleanDistDir: true,
  assetPrefix: "",
  configOrigin: "default",
  useFileSystemPublicRoutes: true,
  generateBuildId: () => null,
  generateEtags: true,
  pageExtensions: ["tsx", "ts", "jsx", "js"],
  target: "server",
  poweredByHeader: true,
  compress: true,
  analyticsId: process.env.VERCEL_ANALYTICS_ID || "",
  images: imageConfigDefault,
  devIndicators: {
    buildActivity: true
  },
  onDemandEntries: {
    maxInactiveAge: 60 * 1e3,
    pagesBufferLength: 2
  },
  amp: {
    canonicalBase: ""
  },
  basePath: "",
  sassOptions: {},
  trailingSlash: false,
  i18n: null,
  productionBrowserSourceMaps: false,
  optimizeFonts: true,
  log: {
    level: "info"
  },
  webpack5: Number(process.env.NEXT_PRIVATE_TEST_WEBPACK4_MODE) > 0 ? false : void 0,
  excludeDefaultMomentLocales: true,
  serverRuntimeConfig: {},
  publicRuntimeConfig: {},
  reactStrictMode: false,
  httpAgentOptions: {
    keepAlive: true
  },
  experimental: {
    swcLoader: false,
    swcMinify: false,
    cpus: Math.max(
      1,
      (Number(process.env.CIRCLE_NODE_TOTAL) || (os.cpus() || { length: 1 }).length) - 1
    ),
    plugins: false,
    profiling: false,
    isrFlushToDisk: true,
    workerThreads: false,
    pageEnv: false,
    optimizeImages: false,
    optimizeCss: false,
    scrollRestoration: false,
    stats: false,
    externalDir: false,
    disableOptimizedLoading: false,
    gzipSize: true,
    craCompat: false,
    esmExternals: false,
    staticPageGenerationTimeout: 60,
    pageDataCollectionTimeout: 60,
    isrMemoryCacheSize: 50 * 1024 * 1024,
    concurrentFeatures: false
  },
  future: {
    strictPostcssConfiguration: false
  }
};
function assignDefaultsBase(userConfig2) {
  const config = Object.keys(userConfig2).reduce((currentConfig, key) => {
    const value = userConfig2[key];
    if (value === void 0 || value === null) {
      return currentConfig;
    }
    if (!!value && value.constructor === Object) {
      currentConfig[key] = __spreadValues(__spreadValues({}, defaultConfig[key]), Object.keys(value).reduce((c, k) => {
        const v = value[k];
        if (v !== void 0 && v !== null) {
          c[k] = v;
        }
        return c;
      }, {}));
    } else {
      currentConfig[key] = value;
    }
    return currentConfig;
  }, {});
  const result = __spreadValues(__spreadValues({}, defaultConfig), config);
  return result;
}
const normalizeConfig = (phase, config) => {
  if (typeof config === "function") {
    config = config(phase, { defaultConfig });
    if (typeof config.then === "function") {
      throw new Error(
        "> Promise returned in blitz config. https://nextjs.org/docs/messages/promise-in-next-config"
      );
    }
  }
  return config;
};
const loadConfig = (pagesDir) => {
  let userConfigModule;
  try {
    const path = join(pagesDir, NEXT_CONFIG_FILE);
    userConfigModule = eval("require")(path);
  } catch (e) {
    console.log("Did not find custom config file");
    userConfigModule = {};
  }
  let userConfig = normalizeConfig(
    PHASE_PRODUCTION_SERVER,
    userConfigModule.default || userConfigModule
  );
  return assignDefaultsBase(userConfig);
};
const topLevelFoldersThatMayContainPages = ["pages", "src", "app", "integrations"];
function getIsRpcFile(filePathFromAppRoot) {
  return /[\\/]queries[\\/]/.test(filePathFromAppRoot) || /[\\/]mutations[\\/]/.test(filePathFromAppRoot);
}
function getIsPageFile(filePathFromAppRoot) {
  return /[\\/]pages[\\/]/.test(filePathFromAppRoot) || /[\\/]api[\\/]/.test(filePathFromAppRoot) || getIsRpcFile(filePathFromAppRoot);
}
function recursiveFindPages(_0, _1, _2) {
  return __async(this, arguments, function* (dir, filter, ignore, arr = [], rootDir = dir) {
    let folders = yield promises.readdir(dir);
    if (dir === rootDir) {
      folders = folders.filter((folder) => topLevelFoldersThatMayContainPages.includes(folder));
    }
    yield Promise.all(
      folders.map((part) => __async(this, null, function* () {
        const absolutePath = join(dir, part);
        if (ignore && ignore.test(part))
          return;
        const pathStat = yield promises.stat(absolutePath);
        if (pathStat.isDirectory()) {
          yield recursiveFindPages(absolutePath, filter, ignore, arr, rootDir);
          return;
        }
        if (!filter.test(part)) {
          return;
        }
        const relativeFromRoot = absolutePath.replace(rootDir, "");
        if (getIsPageFile(relativeFromRoot)) {
          arr.push(relativeFromRoot);
          return;
        }
      }))
    );
    return arr.sort();
  });
}
function buildPageExtensionRegex(pageExtensions) {
  return new RegExp(`(?<!\\.test|\\.spec)\\.(?:${pageExtensions.join("|")})$`);
}
function stripExtension(filePath, pageExtensions) {
  return filePath.replace(new RegExp(`\\.+(${pageExtensions.join("|")})$`), "");
}
function convertPageFilePathToRoutePath(filePath, pageExtensions) {
  return stripExtension(
    filePath.replace(/^.*?[\\/]pages[\\/]/, "/").replace(/^.*?[\\/]api[\\/]/, "/api/").replace(/^.*?[\\/]queries[\\/]/, "/api/rpc/").replace(/^.*?[\\/]mutations[\\/]/, "/api/rpc/"),
    pageExtensions
  );
}
function createPagesMapping(pagePaths, config) {
  const { pageExtensions, blitz } = config;
  const resolverType = (blitz == null ? void 0 : blitz.resolverPath) || "queries|mutations";
  const previousPages = {};
  const pages = pagePaths.reduce((result, pagePath) => {
    let page = `${convertPageFilePathToRoutePath(pagePath, pageExtensions).replace(
      /\\/g,
      "/"
    )}`.replace(/\/index$/, "");
    const isResolver = pagePath.includes("/queries/") || pagePath.includes("/mutations/");
    if (isResolver) {
      if (typeof resolverType === "function") {
        page = `/api/rpc${resolverType(pagePath)}`;
      } else if (resolverType === "root") {
        page = `/api/rpc${stripExtension(pagePath, pageExtensions)}`;
      }
    }
    let pageKey = page === "" ? "/" : page;
    if (pageKey in result) {
      console.warn(
        `Duplicate page detected. ${previousPages[pageKey]} and ${pagePath} both resolve to ${pageKey}.`
      );
    } else {
      previousPages[pageKey] = pagePath;
    }
    result[pageKey] = join(PAGES_DIR_ALIAS, pagePath).replace(/\\/g, "/");
    return result;
  }, {});
  pages["/_app"] = pages["/_app"] || "next/dist/pages/_app";
  pages["/_error"] = pages["/_error"] || "next/dist/pages/_error";
  pages["/_document"] = pages["/_document"] || "next/dist/pages/_document";
  return pages;
}
function collectPages(directory, pageExtensions) {
  return recursiveFindPages(directory, buildPageExtensionRegex(pageExtensions));
}
function getVerb(type) {
  switch (type) {
    case "api":
      return "*";
    case "rpc":
      return "post";
    default:
      return "get";
  }
}
const apiPathRegex = /([\\/]api[\\/])/;
function collectAllRoutes(directory, config) {
  return __async(this, null, function* () {
    const routeFiles = yield collectPages(directory, config.pageExtensions);
    const rawRouteMappings = createPagesMapping(routeFiles, config);
    const routes = [];
    for (const [route, filePath] of Object.entries(rawRouteMappings)) {
      if (["/_app", "/_document", "/_error"].includes(route))
        continue;
      let type;
      if (getIsRpcFile(filePath)) {
        type = "rpc";
      } else if (apiPathRegex.test(filePath)) {
        type = "api";
      } else {
        type = "page";
      }
      routes.push({
        filePath: filePath.replace("private-next-pages/", ""),
        route,
        type,
        verb: getVerb(type)
      });
    }
    return routes;
  });
}
function dedupeBy(arr, by) {
  const allKeys = arr.map(by);
  const countKeys = allKeys.reduce(
    (obj, key) => __spreadProps(__spreadValues({}, obj), { [key]: (obj[key] || 0) + 1 }),
    {}
  );
  const duplicateKeys = Object.keys(countKeys).filter((key) => countKeys[key] > 1);
  if (duplicateKeys.length) {
    duplicateKeys.forEach((key) => {
      let errorMessage = `The page component is named "${key}" on the following routes:

`;
      arr.filter((v) => by(v) === key).forEach(([route]) => {
        errorMessage += `	${route}
`;
      });
      console.error(errorMessage);
    });
    console.error(
      "The page component must have a unique name across all routes, so change the component names so they are all unique.\n"
    );
    if (process.env.NODE_ENV === "production") {
      const error = Error("Duplicate Page Name");
      delete error.stack;
      throw error;
    }
  }
  return arr.filter((v) => !duplicateKeys.includes(by(v)));
}
function setupManifest(routes) {
  const routesWithoutDuplicates = dedupeBy(Object.entries(routes), ([_path, { name }]) => name);
  const implementationLines = routesWithoutDuplicates.map(
    ([path2, { name }]) => `${name}: (query) => ({ pathname: "${path2}", query })`
  );
  const declarationLines = routesWithoutDuplicates.map(
    ([_path, { name, parameters, multipleParameters }]) => {
      if (parameters.length === 0 && multipleParameters.length === 0) {
        return `${name}(query?: ParsedUrlQueryInput): RouteUrlObject`;
      }
      return `${name}(query: { ${[
        ...parameters.map(
          (param) => param.name + (param.optional ? "?" : "") + ": string | number"
        ),
        ...multipleParameters.map(
          (param) => param.name + (param.optional ? "?" : "") + ": (string | number)[]"
        )
      ].join("; ")} } & ParsedUrlQueryInput): RouteUrlObject`;
    }
  );
  const declarationEnding = declarationLines.length > 0 ? ";" : "";
  return {
    implementation: "exports.Routes = {\n" + implementationLines.map((line) => "  " + line).join(",\n") + "\n}",
    declaration: `
import type { ParsedUrlQueryInput } from "querystring"
import type { RouteUrlObject } from "blitz"
export const Routes: {
${declarationLines.map((line) => "  " + line).join(";\n") + declarationEnding}
}`.trim()
  };
}
function removeSquareBracketsFromSegments(value) {
  if (typeof value === "string") {
    return value.replace("[", "").replace("]", "");
  }
  return value.map((val) => val.replace("[", "").replace("]", ""));
}
function partition(arr, predicate) {
  if (!Array.isArray(arr)) {
    throw new Error("expected first argument to be an array");
  }
  if (typeof predicate != "function") {
    throw new Error("expected second argument to be a function");
  }
  var first = [];
  var second = [];
  var length = arr.length;
  for (var i = 0; i < length; i++) {
    var nextValue = arr[i];
    if (predicate(nextValue)) {
      first.push(nextValue);
    } else {
      second.push(nextValue);
    }
  }
  return [first, second];
}
const squareBracketsRegex = /\[\[.*?\]\]|\[.*?\]/g;
function parseParametersFromRoute(path2) {
  var _a;
  const parameteredSegments = (_a = path2.match(squareBracketsRegex)) != null ? _a : [];
  const withoutBrackets = removeSquareBracketsFromSegments(parameteredSegments);
  const [multipleParameters, parameters] = partition(withoutBrackets, (p) => p.includes("..."));
  return {
    parameters: parameters.map((value) => {
      const containsSquareBrackets = squareBracketsRegex.test(value);
      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(value),
          optional: true
        };
      }
      return {
        name: value,
        optional: false
      };
    }),
    multipleParameters: multipleParameters.map((param) => {
      const withoutEllipsis = param.replace("...", "");
      const containsSquareBrackets = squareBracketsRegex.test(withoutEllipsis);
      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(withoutEllipsis),
          optional: true
        };
      }
      return {
        name: withoutEllipsis,
        optional: false
      };
    })
  };
}
const pascalCase = (value) => {
  const val = value.replace(/[-_\s/.]+(.)?/g, (_match, chr) => chr ? chr.toUpperCase() : "");
  return val.substr(0, 1).toUpperCase() + val.substr(1);
};
function parseDefaultExportName(contents) {
  var _a;
  const result = contents.match(/export\s+default(?:\s+(?:const|let|class|var|function))?\s+(\w+)/);
  if (!result) {
    return null;
  }
  return (_a = result[1]) != null ? _a : null;
}
function generateManifest() {
  return __async(this, null, function* () {
    const config = yield loadConfig(process.cwd());
    const allRoutes = yield collectAllRoutes(process.cwd(), config);
    const routes = {};
    for (let { filePath, route, type } of allRoutes) {
      if (type === "api" || type === "rpc")
        continue;
      if (/\.mdx$/.test(filePath)) {
        routes[route] = __spreadProps(__spreadValues({}, parseParametersFromRoute(route)), {
          name: route === "/" ? "Index" : pascalCase(route),
          mdx: true
        });
      } else {
        const fileContents = yield readFile(join(process.cwd(), filePath), {
          encoding: "utf-8"
        });
        const defaultExportName = parseDefaultExportName(fileContents);
        if (!defaultExportName)
          continue;
        routes[route] = __spreadProps(__spreadValues({}, parseParametersFromRoute(route)), {
          name: defaultExportName
        });
      }
    }
    const { declaration, implementation } = setupManifest(routes);
    const dotBlitz = join(yield findNodeModulesRoot(process.cwd()), ".blitz");
    yield outputFile(join(dotBlitz, "index.js"), implementation, {
      encoding: "utf-8"
    });
    yield outputFile(join(dotBlitz, "index-browser.js"), implementation, {
      encoding: "utf-8"
    });
    yield outputFile(join(dotBlitz, "index.d.ts"), declaration, {
      encoding: "utf-8"
    });
  });
}
function findNodeModulesRoot(src) {
  return __async(this, null, function* () {
    var _a;
    let root;
    if (isInternalBlitzMonorepoDevelopment) {
      root = join(__dirname, "..", "..", "..", "..", "/node_modules");
    } else {
      const blitzPkgLocation = dirname(
        (_a = yield findUp("package.json", {
          cwd: resolveFrom(src, "blitz")
        })) != null ? _a : ""
      );
      if (!blitzPkgLocation) {
        throw new Error("Internal Blitz Error: unable to find 'blitz' package location");
      }
      if (blitzPkgLocation.includes(".pnpm")) {
        root = join(blitzPkgLocation, "../../../../");
      } else {
        root = join(blitzPkgLocation, "../");
      }
    }
    return root;
  });
}
let webpackWatcher = null;
function startWatcher(pagesDir2 = "") {
  return __async(this, null, function* () {
    if (webpackWatcher) {
      return;
    }
    let resolved = false;
    return new Promise((resolve) => {
      readdir(pagesDir2, (_, files) => {
        if (files == null ? void 0 : files.length) {
          return;
        }
        if (!resolved) {
          resolve();
          resolved = true;
        }
      });
      let wp = webpackWatcher = new Watchpack({});
      wp.watch(
        [],
        topLevelFoldersThatMayContainPages.map((dir) => join(pagesDir2, dir)),
        Date.now()
      );
      wp.on("aggregated", () => __async(this, null, function* () {
        yield generateManifest();
      }));
    });
  });
}
function stopWatcher() {
  return __async(this, null, function* () {
    if (!webpackWatcher) {
      return;
    }
    webpackWatcher.close();
    webpackWatcher = null;
  });
}

export { stopWatcher as a, collectAllRoutes as c, generateManifest as g, loadConfig as l, startWatcher as s };
