'use strict';

const arg = require('arg');
const chalk = require('chalk');
const logging = require('./logging.cjs');
const chokidar = require('chokidar');
const fs = require('fs');
const os = require('os');
const path = require('path');
const REPL = require('repl');
const ProgressBar = require('progress');
require('tslog');
require('console-table-printer');
require('ora');
require('readline');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const arg__default = /*#__PURE__*/_interopDefaultLegacy(arg);
const chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const os__default = /*#__PURE__*/_interopDefaultLegacy(os);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const REPL__namespace = /*#__PURE__*/_interopNamespace(REPL);
const ProgressBar__default = /*#__PURE__*/_interopDefaultLegacy(ProgressBar);

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug = require("debug")("blitz:repl");
function getDbFolder() {
  try {
    const packageJsonPath = path__default.join(process.cwd(), "package.json");
    const packageJson = fs__default.readFileSync(packageJsonPath, "utf8");
    const packageJsonObj = JSON.parse(packageJson);
    if (!packageJsonObj.prisma || !packageJsonObj.prisma.schema) {
      throw new Error(
        "db/schema.prisma does not exist and Prisma configuration not found in package.json. Please either create the db folder or add the prisma schema path to the package.json"
      );
    }
    const prismaSchemaPath = path__default.join(process.cwd(), packageJsonObj.prisma.schema);
    if (!fs__default.existsSync(prismaSchemaPath)) {
      throw new Error(
        `File not found in ${prismaSchemaPath}. Please either create the db/schema.prisma file or add the prisma schema path to the package.json`
      );
    }
    const folder = packageJsonObj.prisma.schema.split("/")[0];
    return folder;
  } catch (e) {
    if (fs__default.existsSync(path__default.join(process.cwd(), "db/schema.prisma"))) {
      return "db";
    }
    throw e;
  }
}
function getProjectRootSync() {
  return path__default.dirname(getConfigSrcPath());
}
function getConfigSrcPath() {
  const jsPath = path__default.resolve(path__default.join(process.cwd(), "next.config.js"));
  return jsPath;
}
const projectRoot = getProjectRootSync();
const isTypeScript = fs__default.existsSync(path__default.join(projectRoot, "tsconfig.json"));
const invalidateCache = (module2) => {
  delete require.cache[require.resolve(module2)];
};
const forceRequire = (modulePath) => {
  invalidateCache(modulePath);
  const { register } = require("esbuild-register/dist/node");
  const { unregister } = register({
    target: "es6"
  });
  if (isTypeScript) {
    const module2 = require(modulePath);
    unregister();
    return module2;
  } else {
    const esmRequire = require("esm")(module);
    const moduleEsm = esmRequire(modulePath);
    unregister();
    return moduleEsm;
  }
};
function getBlitzModulePaths(onlyDb = false) {
  return __async$1(this, null, function* () {
    const projectRoot2 = getProjectRootSync();
    const paths = [getDbFolder()];
    if (!onlyDb) {
      const { globby } = yield import('globby');
      paths.push(
        ...yield globby(
          [
            "{app,src}/**/{queries,mutations}/**/*.{js,ts,tsx}",
            "utils/*.{js,ts,tsx}",
            "jobs/**/*.{js,ts,tsx}",
            "integrations/**/*.{js,ts,tsx}",
            "!**/*.test.*",
            "!**/*.spec.*"
          ],
          { cwd: projectRoot2, gitignore: true }
        )
      );
    }
    return [...paths.map((p) => path__default.join(projectRoot2, p))];
  });
}
const loadBlitz = (onlyDb, module2 = "") => __async$1(void 0, null, function* () {
  let paths = yield getBlitzModulePaths(onlyDb);
  if (module2) {
    paths = paths.filter((p) => module2.includes(p) || p.includes(module2));
  }
  const percentage = new ProgressBar__default("Loading Modules :current/:total", {
    total: paths.length
  });
  const modules = Object.assign(
    {},
    ...paths.map((modulePath) => {
      let name = path__default.parse(modulePath).name;
      if (name === "index") {
        const dirs = path__default.dirname(modulePath).split(path__default.sep);
        name = dirs[dirs.length - 1];
      }
      try {
        debug("Loading", modulePath);
        const module3 = forceRequire(modulePath);
        const contextObj = module3.default || module3;
        percentage.tick();
        return {
          [name]: contextObj
        };
      } catch (error) {
        logging.log.error(`Failed to load ${modulePath}: ${error}`);
        debug("Failed to load module", error);
        return {};
      }
    })
  );
  percentage.terminate();
  return modules;
});
const loadBlitzModules = (repl, modules) => {
  Object.assign(repl.context, modules);
};
const loadModules = (repl, onlyDb, module2 = "") => __async$1(void 0, null, function* () {
  loadBlitzModules(repl, yield loadBlitz(onlyDb, module2));
});
const commands = {
  reload: {
    help: "Reload all modules",
    action() {
      return __async$1(this, null, function* () {
        this.clearBufferedCommand();
        console.log("Reloading all modules...");
        yield loadModules(this, false);
        this.displayPrompt();
      });
    }
  }
};
const defineCommands = (repl, commands2) => {
  Object.entries(commands2).forEach(([keyword, cmd]) => repl.defineCommand(keyword, cmd));
};
const setupSelfRolledHistory = (repl, path2) => {
  function init() {
    try {
      const history = fs__default.readFileSync(path2, { encoding: "utf8" });
      const nonEmptyLines = history.split(os__default.EOL).filter((line) => line.trim());
      repl.history.push(...nonEmptyLines.reverse());
    } catch (err) {
      if (err.code !== "ENOENT") {
        throw err;
      }
    }
  }
  function onExit() {
    const addedHistory = repl.lines.join(os__default.EOL);
    fs__default.appendFileSync(path2, addedHistory);
  }
  init();
  repl.on("exit", onExit);
};
const setupHistory = (repl) => {
  const blitzConsoleHistoryPath = path__default.join(projectRoot, ".blitz-console-history");
  if (repl.setupHistory) {
    repl.setupHistory(blitzConsoleHistoryPath, () => {
    });
  } else {
    setupSelfRolledHistory(repl, blitzConsoleHistoryPath);
  }
};
const initializeRepl = (replOptions, onlyDb) => __async$1(void 0, null, function* () {
  debug("initializeRepl");
  const modules = yield loadBlitz(onlyDb);
  debug("Starting REPL...");
  const repl = REPL__namespace.start(replOptions);
  const defaultEval = repl.eval;
  repl.eval = (cmd, context, filename, callback) => {
    defaultEval(cmd, context, filename, (err, result) => __async$1(void 0, null, function* () {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, yield Promise.resolve(result));
        } catch (err2) {
          callback(err2);
        }
      }
    }));
  };
  loadBlitzModules(repl, modules);
  defineCommands(repl, commands);
  setupHistory(repl);
  return repl;
});
const setupFileWatchers = (repl) => __async$1(void 0, null, function* () {
  debug("Setting up file watchers...");
  const watchers = [
    chokidar.watch(yield getBlitzModulePaths(), {
      ignoreInitial: true
    }).on("all", (event, path2) => __async$1(void 0, null, function* () {
      const modulePath = path2;
      const modules = yield loadBlitz(false, modulePath);
      loadBlitzModules(repl, modules);
    }))
  ];
  repl.on("reset", () => __async$1(void 0, null, function* () {
    debug("Reset, so reloading modules...");
    yield loadModules(repl, false);
  }));
  repl.on("exit", () => watchers.forEach((watcher) => watcher.close()));
});
const runRepl = (replOptions, onlyDb) => __async$1(void 0, null, function* () {
  const repl = yield initializeRepl(replOptions, onlyDb);
  repl.on("exit", () => process.exit());
  yield setupFileWatchers(repl);
});

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const args = arg__default(
  {
    "--only-db": Boolean,
    "-d": "--only-db"
  },
  {
    permissive: true
  }
);
const replOptions = {
  prompt: "\u26A1\uFE0F > ",
  useColors: true
};
const consoleREPL = () => __async(void 0, null, function* () {
  process.env.CLI_COMMAND_CONSOLE = "true";
  logging.log.branded("You have entered the Blitz console");
  console.log(chalk__default.yellow("Tips: - Exit by typing .exit or pressing Ctrl-D"));
  console.log(chalk__default.yellow(`      - Use your db like this: ${getDbFolder()}.project.findMany()`));
  console.log(chalk__default.yellow("      - Use your queries/mutations like this: getProjects({})"));
  const { register } = require("esbuild-register/dist/node");
  const { unregister } = register({
    target: "es6"
  });
  const onlyDb = args["--only-db"];
  if (onlyDb) {
    console.log(chalk__default.green(`Loading only ${getDbFolder()} module`));
  }
  yield runRepl(replOptions, onlyDb);
  unregister();
});

exports.consoleREPL = consoleREPL;
