import { g as generateManifest } from './routes-manifest.mjs';
import { l as log } from './logging.mjs';
import resolveCwd from 'resolve-cwd';
import { join } from 'path';
import fs__default, { readJSON } from 'fs-extra';
import { existsSync } from 'fs';
import { r as runPrisma } from './run-prisma.mjs';
import resolveFrom from 'resolve-from';

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const getPackageJson = () => __async$1(void 0, null, function* () {
  const pkgJsonPath = join(process.cwd(), "package.json");
  if (existsSync(pkgJsonPath)) {
    return readJSON(pkgJsonPath);
  }
  return {};
});

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const codegenTasks = () => __async(void 0, null, function* () {
  try {
    const nextDir = yield resolveCwd("next");
    const nextClientIndex = join(nextDir, "../..", "client", "index.js");
    const readFile = yield fs__default.readFile(nextClientIndex);
    const packageJson = yield getPackageJson();
    const nextVersion = packageJson.dependencies.next;
    if (nextVersion && nextVersion.startsWith("12")) {
      const updatedFile = readFile.toString().replace(
        /ReactDOM\.hydrateRoot\(.*?\);/,
        `ReactDOM.hydrateRoot(domEl, reactEl, {onRecoverableError: (err) => (err.toString().includes("could not finish this Suspense boundary") || err.toString().includes("Minified React error #419")) ? null : console.error(err)});`
      );
      yield fs__default.writeFile(nextClientIndex, updatedFile);
      log.success("Next.js was successfully patched with a React Suspense fix");
    } else if (nextVersion && nextVersion.startsWith("13")) {
      const updatedFile = readFile.toString().replace(
        /_client.default\.hydrateRoot\(.*?\);/,
        `_client.default.hydrateRoot(domEl, reactEl, {onRecoverableError: (err) => (err.toString().includes("could not finish this Suspense boundary") || err.toString().includes("Minified React error #419")) ? null : console.error(err)});`
      );
      yield fs__default.writeFile(nextClientIndex, updatedFile);
      log.success("Next.js was successfully patched with a React Suspense fix");
    }
  } catch (err) {
    log.error(JSON.stringify(err, null, 2));
  }
  try {
    yield generateManifest();
    log.success("Routes manifest was successfully generated");
    const { dependencies, devDependencies } = yield getPackageJson();
    const hasPrisma = Object.keys(__spreadValues(__spreadValues({}, dependencies), devDependencies)).some(
      (name) => name === "prisma"
    );
    if (hasPrisma) {
      const foundPrismaClient = resolveFrom.silent(process.cwd(), "@prisma/client");
      const foundDotPrismaClient = resolveFrom.silent(process.cwd(), ".prisma");
      if (!foundPrismaClient || foundPrismaClient && !fs__default.existsSync(join(foundPrismaClient, "../../..", ".prisma")) || foundDotPrismaClient && !foundDotPrismaClient) {
        let prismaSpinner = log.spinner(`Generating Prisma client`).start();
        const result = yield runPrisma(["generate"], true);
        if (typeof result === "object") {
          if (result.success) {
            prismaSpinner.succeed(log.greenText("Generated Prisma client"));
          } else {
            prismaSpinner.fail();
            console.log("\n" + result.stderr);
            process.exit(1);
          }
        }
      }
    }
  } catch (err) {
    log.error(JSON.stringify(err, null, 2));
  }
});

export { codegenTasks as c };
