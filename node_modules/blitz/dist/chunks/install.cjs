'use strict';

const arg = require('arg');
const prompts = require('prompts');
const globalAgent = require('global-agent');
const logging = require('./logging.cjs');
const path = require('path');
const stream = require('stream');
const util = require('util');
const tsNode = require('ts-node');
const helpers = require('./helpers.cjs');
const findUp = require('find-up');
const resolveFrom = require('resolve-from');
require('tslog');
require('chalk');
require('console-table-printer');
require('ora');
require('readline');
require('fs-extra');
require('cross-spawn');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const arg__default = /*#__PURE__*/_interopDefaultLegacy(arg);
const prompts__default = /*#__PURE__*/_interopDefaultLegacy(prompts);
const findUp__default = /*#__PURE__*/_interopDefaultLegacy(findUp);
const resolveFrom__default = /*#__PURE__*/_interopDefaultLegacy(resolveFrom);

const setupTsnode = () => {
  if (!process[tsNode.REGISTER_INSTANCE]) {
    require("ts-node").register({ compilerOptions: { module: "commonjs" } });
  }
  require("tsconfig-paths/register");
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug = require("debug")("blitz:cli");
const args = arg__default(
  {
    "--help": Boolean,
    "--env": String,
    "--yes": Boolean,
    "-e": "--env",
    "-y": "--yes"
  },
  {
    permissive: true
  }
);
const pipeline = util.promisify(stream.Stream.pipeline);
const got = (url) => __async(void 0, null, function* () {
  return require("got")(url).catch((e) => {
    if (e.response.statusCode === 403) {
      logging.baseLogger({ displayDateTime: false }).error(e.response.body);
    } else {
      return e;
    }
  });
});
const gotJSON = (url) => __async(void 0, null, function* () {
  debug("[gotJSON] Downloading json from ", url);
  const res = yield got(url);
  return JSON.parse(res.body);
});
const isUrlValid = (url) => __async(void 0, null, function* () {
  return (yield got(url).catch((e) => e)).statusCode === 200;
});
const requireJSON = (file) => {
  return JSON.parse(require("fs-extra").readFileSync(file).toString("utf-8"));
};
const checkLockFileExists = (filename) => __async(void 0, null, function* () {
  const dotBlitz = path.join(yield findNodeModulesRoot(process.cwd()), ".blitz");
  return require("fs-extra").existsSync(path.resolve(path.join(dotBlitz, "..", "..", filename)));
});
const GH_ROOT = "https://github.com/";
const API_ROOT = "https://api.github.com/repos/";
const RAW_ROOT = "https://raw.githubusercontent.com/";
const CODE_ROOT = "https://codeload.github.com/";
var RecipeLocation = /* @__PURE__ */ ((RecipeLocation2) => {
  RecipeLocation2[RecipeLocation2["Local"] = 0] = "Local";
  RecipeLocation2[RecipeLocation2["Remote"] = 1] = "Remote";
  return RecipeLocation2;
})(RecipeLocation || {});
const getOfficialRecipeList = () => __async(void 0, null, function* () {
  return yield gotJSON(`${API_ROOT}blitz-js/blitz/git/trees/main?recursive=1`).then(
    (release) => release.tree.reduce((recipesList, item) => {
      const filePath = item.path.split("/");
      const [directory, recipeName] = filePath;
      if (directory === "recipes" && filePath.length === 2 && item.type === "tree" && recipeName) {
        recipesList.push(recipeName);
      }
      return recipesList;
    }, [])
  );
});
const normalizeRecipePath = (recipeArg) => {
  const isNativeRecipe = /^([\w\-_]*)$/.test(recipeArg);
  const isUrlRecipe = recipeArg.startsWith(GH_ROOT);
  const isGitHubShorthandRecipe = /^([\w-_]*)\/([\w-_]*)$/.test(recipeArg);
  if (isNativeRecipe || isUrlRecipe || isGitHubShorthandRecipe) {
    let repoUrl;
    let subdirectory;
    switch (true) {
      case isUrlRecipe:
        repoUrl = recipeArg;
        break;
      case isNativeRecipe:
        repoUrl = `${GH_ROOT}blitz-js/blitz`;
        subdirectory = `recipes/${recipeArg}`;
        break;
      case isGitHubShorthandRecipe:
        repoUrl = `${GH_ROOT}${recipeArg}`;
        break;
      default:
        throw new Error(
          "should be impossible, the 3 cases are the only way to get into this switch"
        );
    }
    return {
      path: repoUrl,
      subdirectory,
      location: 1 /* Remote */
    };
  } else {
    return {
      path: recipeArg,
      location: 0 /* Local */
    };
  }
};
function findNodeModulesRoot(src) {
  return __async(this, null, function* () {
    var _a;
    let root;
    if (helpers.isInternalBlitzMonorepoDevelopment) {
      root = path.join(__dirname, "..", "..", "..", "..", "/node_modules");
    } else {
      const blitzPkgLocation = path.dirname(
        (_a = yield findUp__default("package.json", {
          cwd: resolveFrom__default(src, "blitz")
        })) != null ? _a : ""
      );
      if (!blitzPkgLocation) {
        throw new Error("Internal Blitz Error: unable to find 'blitz' package location");
      }
      if (blitzPkgLocation.includes(".pnpm")) {
        root = path.join(blitzPkgLocation, "../../../../");
      } else {
        root = path.join(blitzPkgLocation, "../");
      }
    }
    return root;
  });
}
const cloneRepo = (repoFullName, defaultBranch, subdirectory) => __async(void 0, null, function* () {
  debug("[cloneRepo] starting...");
  const dotBlitz = path.join(yield findNodeModulesRoot(process.cwd()), ".blitz");
  const recipeDir = path.join(dotBlitz, "..", "..", "recipe-install");
  require("rimraf").sync(recipeDir);
  require("fs-extra").mkdirsSync(recipeDir);
  process.chdir(recipeDir);
  debug("Extracting recipe to ", recipeDir);
  const repoName = repoFullName.split("/")[1];
  const extractPath = subdirectory ? [`${repoName}-${defaultBranch}/${subdirectory}`] : void 0;
  const depth = subdirectory ? subdirectory.split("/").length + 1 : 1;
  yield pipeline(
    require("got").stream(`${CODE_ROOT}${repoFullName}/tar.gz/${defaultBranch}`),
    require("tar").extract({ strip: depth }, extractPath)
  );
  return recipeDir;
});
const installRecipeAtPath = (recipePath, ...runArgs) => __async(void 0, null, function* () {
  const recipe = require(recipePath).default;
  yield recipe.run(...runArgs);
});
const setupProxySupport = () => __async(void 0, null, function* () {
  const httpProxy = process.env.http_proxy || process.env.HTTP_PROXY;
  const httpsProxy = process.env.https_proxy || process.env.HTTPS_PROXY;
  const noProxy = process.env.no_proxy || process.env.NO_PROXY;
  if (httpProxy || httpsProxy) {
    globalThis.GLOBAL_AGENT = {
      HTTP_PROXY: httpProxy,
      HTTPS_PROXY: httpsProxy,
      NO_PROXY: noProxy
    };
    globalAgent.bootstrap();
  }
});
const install = () => __async(void 0, null, function* () {
  var _a;
  setupTsnode();
  let selectedRecipe = args._[1] ? `${args._[1]}` : null;
  yield setupProxySupport();
  if (!selectedRecipe) {
    const officialRecipeList = yield getOfficialRecipeList();
    const res = yield prompts__default({
      type: "select",
      name: "recipeName",
      message: "Select a recipe to install",
      choices: officialRecipeList.map((r) => {
        return { title: r, value: r };
      })
    });
    selectedRecipe = res.recipeName;
  }
  if (selectedRecipe) {
    const recipeInfo = normalizeRecipePath(selectedRecipe);
    const cliArgs = args._.filter((arg2) => !arg2.startsWith("--")).slice(2).reduce(
      (acc, arg2) => __spreadProps(__spreadValues({}, acc), {
        [`${arg2.split("=")[0]}`]: arg2.split("=")[1] ? JSON.parse(`"${arg2.split("=")[1]}"`) : true
      }),
      {}
    );
    const cliFlags = {
      yesToAll: args["--yes"] || false
    };
    const chalk = (yield import('chalk')).default;
    if (recipeInfo.location === 1 /* Remote */) {
      const apiUrl = recipeInfo.path.replace(GH_ROOT, API_ROOT);
      const rawUrl = recipeInfo.path.replace(GH_ROOT, RAW_ROOT);
      const repoInfo = yield gotJSON(apiUrl);
      const packageJsonPath = path.join(
        `${rawUrl}`,
        repoInfo.default_branch,
        (_a = recipeInfo.subdirectory) != null ? _a : "",
        "package.json"
      );
      if (!(yield isUrlValid(packageJsonPath))) {
        debug("Url is invalid for ", packageJsonPath);
        logging.baseLogger({ displayDateTime: false }).error(`Could not find recipe "${args._[1]}"
`);
        console.log(`${chalk.bold("Please provide one of the following:")}

1. The name of a recipe to install (e.g. "tailwind")
${chalk.dim("- Available recipes listed at https://github.com/blitz-js/blitz/tree/main/recipes")}
2. The full name of a GitHub repository (e.g. "blitz-js/example-recipe"),
3. A full URL to a Github repository (e.g. "https://github.com/blitz-js/example-recipe"), or
4. A file path to a locally-written recipe.
`);
        process.exit(1);
      } else {
        let spinner = logging.log.spinner(`Cloning GitHub repository for ${selectedRecipe} recipe`).start();
        const recipeRepoPath = yield cloneRepo(
          repoInfo.full_name,
          repoInfo.default_branch,
          recipeInfo.subdirectory
        );
        spinner.stop();
        spinner = logging.log.spinner("Installing package.json dependencies").start();
        let pkgManager = "npm";
        let installArgs = ["install", "--legacy-peer-deps", "--ignore-scripts"];
        if (yield checkLockFileExists("yarn.lock")) {
          pkgManager = "yarn";
          installArgs = ["install", "--ignore-scripts"];
        } else if (yield checkLockFileExists("pnpm-lock.yaml")) {
          pkgManager = "pnpm";
          installArgs = ["install", "--ignore-scripts"];
        }
        yield new Promise((resolve2) => {
          const installProcess = require("cross-spawn")(pkgManager, installArgs);
          installProcess.on("exit", resolve2);
        });
        spinner.stop();
        const recipePackageMain = requireJSON("./package.json").main;
        const recipeEntry = path.resolve(recipePackageMain);
        process.chdir(path.join(process.cwd(), ".."));
        yield installRecipeAtPath(recipeEntry, cliArgs, cliFlags);
        require("rimraf").sync(recipeRepoPath);
      }
    } else {
      try {
        yield installRecipeAtPath(path.resolve(`${args._[1]}`), cliArgs, cliFlags);
      } catch (err) {
        if (err instanceof Error) {
          throw new Error(err.message);
        }
        console.log(err);
      }
    }
  }
});

exports.RecipeLocation = RecipeLocation;
exports.install = install;
