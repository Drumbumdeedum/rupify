'use strict';

const prompts = require('prompts');
const path = require('path');
const chalk = require('chalk');
const hasbin = require('hasbin');
const arg = require('arg');
const generator = require('@blitzjs/generator');
const index = require('./index2.cjs');
const runPrisma = require('./run-prisma.cjs');
const helpers = require('./helpers.cjs');
const codegenTasks = require('./codegen-tasks.cjs');
require('cross-spawn');
require('fs');
require('dotenv');
require('dotenv-expand');
require('fs-extra');
require('pkg-dir');
require('resolve-cwd');
require('resolve-from');
require('p-event');
require('./routes-manifest.cjs');
require('os');
require('find-up');
require('watchpack');
require('./logging.cjs');
require('tslog');
require('console-table-printer');
require('ora');
require('readline');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const prompts__default = /*#__PURE__*/_interopDefaultLegacy(prompts);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
const hasbin__default = /*#__PURE__*/_interopDefaultLegacy(hasbin);
const arg__default = /*#__PURE__*/_interopDefaultLegacy(arg);

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const returnNpmEndpoint = (packageName) => {
  return `https://registry.npmjs.org/-/package/${packageName}/dist-tags`;
};
function getUpdateString(packageName, tag, isGlobal) {
  const globalPkgManager = helpers.getGlobalPkgManager();
  switch (globalPkgManager) {
    case "npm":
      return `npm install${isGlobal ? " -g" : ""} ${packageName}@${tag}`;
    case "yarn":
      return `yarn${isGlobal ? " global" : ""} add ${packageName}@${tag}`;
    case "pnpm":
      return `pnpm install${isGlobal ? " -g" : ""} ${packageName}@${tag}`;
  }
}
function checkLatestVersion() {
  return __async$1(this, null, function* () {
    if (!helpers.isInternalBlitzMonorepoDevelopment) {
      const fetch = yield import('node-fetch');
      const boxen = yield import('boxen');
      const versions = index.readVersions();
      const versionsArray = Object.entries(versions);
      let errors = [];
      try {
        const blitzResponse = yield fetch.default(returnNpmEndpoint("blitz"));
        const remoteBlitzVersions = yield blitzResponse.json();
        for (const version of versionsArray) {
          const versionType = version[0];
          const versionValue = version[1];
          if (versionType === "globalVersion" && typeof versionValue === "string" && versionValue !== "") {
            if (remoteBlitzVersions["latest"] !== versionValue) {
              errors.push({
                message: `blitz(global) (current) ${versionValue} -> (latest) ${remoteBlitzVersions["latest"]}`,
                instructions: `${getUpdateString("blitz", "latest", true)}`
              });
            }
          } else if (versionType === "localVersions" && typeof versionValue === "object" && versionValue.blitz && versionValue.blitz !== "") {
            if (remoteBlitzVersions["latest"] !== versionValue.blitz) {
              errors.push({
                message: `blitz(current) ${versionValue.blitz} -> (latest) ${remoteBlitzVersions["latest"]}`,
                instructions: `${getUpdateString("blitz", "latest", true)}`
              });
            }
          }
        }
        if (errors.length) {
          console.log(
            boxen.default(
              `You are running outdated blitz packages

${errors.map((e) => e.message).join("\n")} 

Run the following to update:
${errors.map((e) => e.instructions).join("\n")}`,
              { padding: 1 }
            )
          );
        }
      } catch (err) {
        if (err instanceof fetch.FetchError) ; else {
          console.log(err);
        }
      }
    }
  });
}

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const forms = {
  finalform: "React Final Form (recommended)",
  hookform: "React Hook Form",
  formik: "Formik"
};
const language = {
  typescript: "TypeScript",
  javascript: "JavaScript"
};
const installCommandMap = {
  yarn: "yarn",
  pnpm: "pnpm install",
  npm: "npm install"
};
const templates = {
  full: {
    path: "app"
  },
  minimal: {
    path: "minimalapp",
    skipForms: true,
    skipDatabase: true
  }
};
const IS_YARN_INSTALLED = hasbin__default.sync("yarn");
const IS_PNPM_INSTALLED = hasbin__default.sync("pnpm");
const PREFERABLE_PKG_MANAGER = IS_PNPM_INSTALLED ? "pnpm" : IS_YARN_INSTALLED ? "yarn" : "npm";
const args = arg__default(
  {
    "--npm": Boolean,
    "--yarn": Boolean,
    "--pnpm": Boolean,
    "--form": String,
    "--language": String,
    "--template": String,
    "--skip-install": Boolean,
    "--dry-run": Boolean,
    "--no-git": Boolean,
    "--skip-upgrade": Boolean
  },
  {
    permissive: true
  }
);
let projectName = "";
let projectPath = "";
let projectLanguage = "";
let projectFormLib = "finalform";
let projectTemplate = templates.full;
let projectPkgManger = PREFERABLE_PKG_MANAGER;
let shouldInstallDeps = true;
const determineProjectName = () => __async(void 0, null, function* () {
  if (args._.slice(1).length < 1) {
    const res = yield prompts__default({
      type: "text",
      name: "name",
      message: "What would you like to name your project?",
      initial: "blitz-app"
    });
    projectName = res.name.trim().replaceAll(" ", "-");
    projectPath = path__default.resolve(projectName);
  } else {
    projectName = args._.slice(1)[0];
    if (projectName === ".") {
      projectName = path__default.basename(process.cwd());
    }
    projectPath = path__default.resolve(projectName);
  }
});
const determineLanguage = () => __async(void 0, null, function* () {
  if (!args["--language"] || args["--language"] && !Object.keys(language).includes(args["--language"].toLowerCase())) {
    const res = yield prompts__default({
      type: "select",
      name: "language",
      message: "Pick a new project's language",
      initial: 0,
      choices: Object.entries(language).map((c) => {
        return { title: c[1], value: c[1] };
      })
    });
    projectLanguage = res.language;
  } else {
    projectLanguage = args["--language"];
  }
});
const determineFormLib = () => __async(void 0, null, function* () {
  if (!args["--form"] || args["--form"] && !Object.keys(forms).includes(args["--form"])) {
    const res = yield prompts__default({
      type: "select",
      name: "form",
      message: "Pick a form library (you can switch to something else later if you want)",
      initial: 0,
      choices: Object.entries(forms).map((c) => {
        return { value: c[0], title: c[1] };
      })
    });
    projectFormLib = res.form;
  } else {
    projectFormLib = args["--form"];
  }
});
const determineTemplate = () => __async(void 0, null, function* () {
  if (!args["--template"] || args["--template"] && !Object.keys(templates).includes(args["--template"].toLowerCase())) {
    const choices = [
      { value: "full", title: "Full - includes DB and auth (Recommended)" },
      { value: "minimal", title: "Minimal \u2014 no DB, no auth" }
    ];
    const res = yield prompts__default({
      type: "select",
      name: "template",
      message: "Pick your new app template",
      initial: 0,
      choices
    });
    projectTemplate = templates[res.template];
  } else {
    projectTemplate = templates[args["--template"]];
  }
});
const determinePkgManagerToInstallDeps = () => __async(void 0, null, function* () {
  if (args["--skip-install"]) {
    shouldInstallDeps = false;
    return;
  }
  const isPkgManagerSpecifiedAsFlag = args["--npm"] || args["--yarn"] || args["--pnpm"];
  if (isPkgManagerSpecifiedAsFlag) {
    if (args["--npm"]) {
      projectPkgManger = "npm";
    } else if (args["--pnpm"]) {
      if (IS_PNPM_INSTALLED) {
        projectPkgManger = "pnpm";
      } else {
        console.warn(`Pnpm is not installed. Fallback to ${projectPkgManger}`);
      }
    } else if (args["--yarn"]) {
      if (IS_YARN_INSTALLED) {
        projectPkgManger = "yarn";
      } else {
        console.warn(`Yarn is not installed. Fallback to ${projectPkgManger}`);
      }
    }
  } else {
    const hasPkgManagerChoice = IS_YARN_INSTALLED || IS_PNPM_INSTALLED;
    if (hasPkgManagerChoice) {
      const res = yield prompts__default({
        type: "select",
        name: "pkgManager",
        message: "Install dependencies?",
        initial: 0,
        choices: [
          { title: "npm", value: "npm" },
          { title: "yarn", value: "yarn", disabled: !IS_YARN_INSTALLED },
          { title: "pnpm", value: "pnpm", disabled: !IS_PNPM_INSTALLED },
          { title: "skip", value: "skip" }
        ]
      });
      if (res.pkgManager === "skip") {
        projectPkgManger = PREFERABLE_PKG_MANAGER;
      } else {
        projectPkgManger = res.pkgManager;
      }
      shouldInstallDeps = res.pkgManager !== "skip";
    } else {
      const res = yield prompts__default({
        type: "confirm",
        name: "installDeps",
        message: "Install dependencies?",
        initial: true
      });
      shouldInstallDeps = res.installDeps;
    }
  }
});
const newApp = (argv) => __async(void 0, null, function* () {
  const shouldUpgrade = !args["--skip-upgrade"];
  if (shouldUpgrade) {
    yield checkLatestVersion();
  }
  yield determineProjectName();
  yield determineLanguage();
  yield determineTemplate();
  yield determinePkgManagerToInstallDeps();
  if (!projectTemplate.skipForms) {
    yield determineFormLib();
  }
  try {
    const latestBlitzVersion = (yield generator.getLatestVersion("blitz")).value;
    const requireManualInstall = args["--dry-run"] || !shouldInstallDeps;
    const postInstallSteps = projectName === "." ? [] : [`cd ${projectName}`];
    const generatorOpts = {
      template: projectTemplate,
      destinationRoot: projectPath,
      appName: projectName,
      useTs: projectLanguage === "TypeScript",
      yarn: projectPkgManger === "yarn",
      pnpm: projectPkgManger === "pnpm",
      dryRun: args["--dry-run"] ? args["--dry-run"] : false,
      skipGit: args["--no-git"] ? args["--no-git"] : false,
      skipInstall: !shouldInstallDeps,
      version: latestBlitzVersion,
      form: projectFormLib,
      onPostInstall: () => __async(void 0, null, function* () {
        if (projectTemplate.skipDatabase) {
          return;
        }
        try {
          index.loadEnvConfig(
            process.cwd(),
            void 0,
            { error: console.error, info: () => {
            } },
            { ignoreCache: true }
          );
          const result = yield runPrisma.runPrisma(["migrate", "dev", "--name", "Initial migration"], true);
          if (!result.success)
            throw new Error();
          if (projectPkgManger === "yarn") {
            yield codegenTasks.codegenTasks();
          }
        } catch (error) {
          postInstallSteps.push(
            "blitz prisma migrate dev (when asked, you can name the migration anything)"
          );
        }
      })
    };
    const generator$1 = new generator.AppGenerator(generatorOpts);
    console.log(`Hang tight while we set up your new Blitz app!`);
    yield generator$1.run();
    if (requireManualInstall) {
      postInstallSteps.push(installCommandMap[projectPkgManger]);
      postInstallSteps.push(
        "blitz prisma migrate dev (when asked, you can name the migration anything)"
      );
    }
    postInstallSteps.push("blitz dev");
    console.log("\n Your new Blitz app is ready! Next steps:");
    postInstallSteps.forEach((step, index) => {
      console.log(chalk__default.yellow(`   ${index + 1}. ${step}`));
    });
    console.log("");
    process.exit(0);
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
});

exports.newApp = newApp;
