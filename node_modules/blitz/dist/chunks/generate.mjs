import arg from 'arg';
import prompts from 'prompts';
import { customTemplatesBlitzConfig, uncapitalize, capitalize, singleCamel, pluralCamel, singlePascal, pluralPascal, PageGenerator, FormGenerator, QueriesGenerator, MutationsGenerator, ModelGenerator, QueryGenerator, MutationGenerator } from '@blitzjs/generator';
import { l as log } from './logging.mjs';
import 'tslog';
import 'chalk';
import 'console-table-printer';
import 'ora';
import 'readline';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var _a;
const getIsTypeScript = () => __async(void 0, null, function* () {
  return require("fs").existsSync(require("path").join(process.cwd(), "tsconfig.json"));
});
function modelName(input = "") {
  return singleCamel(input);
}
function modelNames(input = "") {
  return pluralCamel(input);
}
function ModelName(input = "") {
  return singlePascal(input);
}
function ModelNames(input = "") {
  return pluralPascal(input);
}
const createCustomTemplates = () => __async(void 0, null, function* () {
  const continuePrompt = yield prompts({
    type: "confirm",
    name: "value",
    message: `This will copy the default templates to your app/templates folder. Do you want to continue?`
  });
  if (!continuePrompt.value) {
    process.exit(0);
  }
  const templatesPath = yield prompts({
    type: "text",
    name: "value",
    message: `Enter the path to save the custom templates folder`,
    initial: "app/templates"
  });
  const templatesPathValue = templatesPath.value;
  const isTypeScript = yield getIsTypeScript();
  yield customTemplatesBlitzConfig(isTypeScript, templatesPathValue, true);
  log.success(`\u{1F680} Custom templates path added/updated in app/blitz-server file`);
  const customTemplatesPath = require("path").join(process.cwd(), templatesPathValue);
  const fsExtra = yield import('fs-extra');
  const blitzGeneratorPath = require.resolve("@blitzjs/generator");
  const templateFolder = ["form", "page", "query", "mutation", "queries", "mutations"];
  for (const template of templateFolder) {
    yield fsExtra.copy(
      require("path").join(blitzGeneratorPath, "..", "templates", template),
      require("path").join(customTemplatesPath, template)
    );
  }
  log.success(`\u{1F680} Custom templates created in ${templatesPathValue} directory`);
  process.exit(0);
});
const generatorMap = {
  ["all" /* All */]: [
    PageGenerator,
    FormGenerator,
    QueriesGenerator,
    MutationsGenerator,
    ModelGenerator
  ],
  ["crud" /* Crud */]: [MutationsGenerator, QueriesGenerator],
  ["model" /* Model */]: [ModelGenerator],
  ["pages" /* Pages */]: [PageGenerator, FormGenerator],
  ["queries" /* Queries */]: [QueriesGenerator],
  ["query" /* Query */]: [QueryGenerator],
  ["mutations" /* Mutations */]: [MutationsGenerator],
  ["mutation" /* Mutation */]: [MutationGenerator],
  ["resource" /* Resource */]: [QueriesGenerator, MutationsGenerator, ModelGenerator],
  ["custom-templates" /* CustomTemplates */]: []
};
const args = arg(
  {
    "--help": Boolean,
    "--type": String,
    "--context": String,
    "--parent": String,
    "--dry-run": Boolean,
    "--env": String,
    "-e": "--env",
    "-t": "--type",
    "-c": "--context",
    "-p": "--parent",
    "-d": "--dry-run"
  },
  {
    permissive: true
  }
);
let selectedType;
let selectedModelName;
let selectedContext;
let selectedParent = (_a = args["--parent"]) != null ? _a : void 0;
const getModelNameAndContext = (modelName2, context) => {
  const modelSegments = modelName2.split(/[\\/]/);
  if (modelSegments.length > 1) {
    return {
      model: modelSegments[modelSegments.length - 1],
      context: require("path").join(...modelSegments.slice(0, modelSegments.length - 1))
    };
  }
  if (Boolean(context)) {
    const contextSegments = context.split(/[\\/]/);
    return {
      model: modelName2,
      context: require("path").join(...contextSegments)
    };
  }
  return {
    model: modelName2
  };
};
const validateModelName = (modelName2) => {
  const RESERVED_MODEL_NAMES = ["page", "api", "query", "mutation"];
  if (RESERVED_MODEL_NAMES.includes(modelName2)) {
    throw new Error(`Names ${RESERVED_MODEL_NAMES} or their plurals cannot be used as model names`);
  }
  if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(modelName2)) {
    throw new Error(
      `Invalid model name: "${modelName2}". Model names need to adhere to this regular expression: [A-Za-z][A-Za-z0-9_]*`
    );
  }
};
const determineType = () => __async(void 0, null, function* () {
  var _a2, _b;
  if (!args["_"].slice(1)[0] || args["_"].slice(1)[0] && !Object.keys(generatorMap).includes((_a2 = args["_"].slice(1)[0]) == null ? void 0 : _a2.toLowerCase())) {
    const res = yield prompts({
      type: "select",
      name: "type",
      message: "Which files to generate",
      initial: 0,
      choices: Object.entries(generatorMap).map((c) => {
        return { title: c[0], value: c[0] };
      })
    });
    selectedType = res.type;
  } else {
    selectedType = (_b = args["_"].slice(1)[0]) == null ? void 0 : _b.toLowerCase();
  }
});
const determineName = () => __async(void 0, null, function* () {
  if (!args["_"].slice(1)[1]) {
    const res = yield prompts({
      type: "text",
      name: "model",
      message: `The name of your model, like "user". Can be singular or plural - same result`
    });
    const { model, context } = getModelNameAndContext(res.model);
    selectedModelName = model;
    selectedContext = context;
  } else {
    const { model, context } = getModelNameAndContext(args["_"].slice(1)[1]);
    selectedModelName = model;
    selectedContext = context;
  }
});
const determineContext = () => __async(void 0, null, function* () {
  if (args["--context"] && selectedModelName && !selectedContext) {
    selectedContext = args["--context"];
  }
});
const getHelp = () => __async(void 0, null, function* () {
  if (args["--help"]) {
    console.log(`
      # The 'crud' type will generate all queries & mutations for a model

        > blitz generate crud productVariant

      # The 'all' generator will scaffold out everything possible for a model

        > blitz generate all products

      # The '--context' flag will allow you to generate files such as components, queries & mutations in a nested folder

        > blitz generate pages projects --context=admin

      # Context can also be supplied in the model name directly

        > blitz generate pages admin/projects

      # To generate nested routes for dependent models (e.g. Projects that contain Tasks), specify a parent model.
      For example, this command generates pages under pages/projects/[projectId]/tasks/

        > blitz generate all tasks --parent=projects

      # To customize the templates used by the blitz generate command,
        
        > blitz generate custom-templates

        This command will copy the default templates to your app and update the app/blitz-server file to enable
        the custom templating feature of the blitz CLI

      # Database models can also be generated directly from the CLI.
        Model fields can be specified with any generator that generates a database model ("all", "model", "resource").
        Both of the commands below will generate the proper database model for a Task.

        > blitz generate model task name:string completed:boolean:default=false belongsTo:project?

        > blitz generate all tasks name:string completed:boolean:default=false belongsTo:project?

    `);
    process.exit(0);
  }
});
const generate = () => __async(void 0, null, function* () {
  yield getHelp();
  yield determineType();
  if (selectedType === "custom-templates") {
    yield createCustomTemplates();
  }
  if (!selectedModelName) {
    yield determineName();
  }
  yield determineContext();
  try {
    const singularRootContext = modelName(selectedModelName);
    validateModelName(singularRootContext);
    const generators = generatorMap[selectedType];
    const isTypeScript = yield getIsTypeScript();
    const cliConfig = yield customTemplatesBlitzConfig(isTypeScript);
    for (const GeneratorClass of generators) {
      const generator = new GeneratorClass({
        destinationRoot: require("path").resolve(),
        templateDir: cliConfig,
        extraArgs: args["_"].slice(3),
        modelName: singularRootContext,
        modelNames: modelNames(singularRootContext),
        ModelName: ModelName(singularRootContext),
        ModelNames: ModelNames(singularRootContext),
        parentModel: modelName(selectedParent),
        parentModels: modelNames(selectedParent),
        ParentModel: ModelName(selectedParent),
        ParentModels: ModelNames(selectedParent),
        name: uncapitalize(selectedModelName),
        Name: capitalize(selectedModelName),
        dryRun: args["--dry-run"],
        context: selectedContext,
        useTs: yield getIsTypeScript()
      });
      yield generator.run();
    }
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
});

export { generate };
